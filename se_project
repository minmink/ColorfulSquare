---
title: se_project_test
layout: post
author: yaup22c
permalink: /test
source-id: 1akXrGIsplA6qgUdru7SCuSeVa_5Yrf7iGXPD9PnaaUc
published: true
---
Design

Specification

[[TOC]]

**목차**

1. Preface

    1. Objective

    2. Readership

    3. Document Structure

        1. Preface

        2. Introduction

        3. System Architecture

        4. User Management System

        5. Furniture Information System

        6. Color Analyzing System

        7. Personalizing System

        8. Image Processor System

        9. Protocol Design

        10. Database Design

        11. Testing Plan

        12. Development Environment

        13. Develop Plan

        14. Index

    4. Document Version

        15. Version Format

        16. Version Management

        17. Version Update History

1. Introduction

    5. Objective

    6. Applied Diagram

    7. Applied Tool

    8. Project Scope

2. System Architecture

    9. Objective

    10. System Organization

        18. User Management System

        19. Furniture Information System

        20. Color Analyzing System

        21. Personalizing System

        22. Image Processor System

3. User Management System

1. Objective

2. Class Diagram

	1. DB Handler

	2. User

C. Sequence Diagram

	1. Sign up using Facebook

	2. Sign in using Facebook

	3. Sign up without using Facebook

	4. Sign in without using Facebook

D.  State Diagram

	1. Sign up

	2. Sign in

4. Furniture Information System

1. Objective

2. Class Diagram

	1. DB Handler

	2. Furniture

     3. Color

	 4. Gather Information

	 5. Gather Color Information

	 6. Gather Color Information

    C. Sequence Diagram

	1. Setup Furniture Data System

     2. Update Furniture Data System

D.  State Diagram

	1. Setup Furniture Data System

     2. Update Furniture Data System

5. Color Analyzing System

1. Objective

2. Class Diagram

	1. DB Handler

	2. Furniture

	3. Color

	4. Gather Information

	5. Gather Furniture Information

	6. Gather Color Information

	7. Compare

8. Image Producing

    C. Sequence Diagram

	1. Color Analyzing System

	2. Color Comparison System

    D. State Diagram

	1. Color Analyzing System

	2. Color Comparison System

6. Personalizing System

1. Objective

2. Class Diagram

	1. DB Handler

	2. Classifier

    C. Sequence Diagram

	1. Furniture Recommendation System

	2. Learning Recommendation System

    D. State Diagram

1. Furniture Recommendation System

	2. Learning Recommendation System

7. Image Processor System

1. Objective

2. Class Diagram

	1. DB Handler

	2. Furniture

	3. Image Handler

	4. 3D Model handler

	5. Gather Information

	6. Gather Color Information

    C. Sequence Diagram

	1. Image Generating System

	2. Furniture Arrangement System

    D. State Diagram

	1. Image Generating System

	2. Furniture Arrangement System

8. Protocol Design

    11. Objective

    12. JSON

    13. Protocol Description

1. Overview

2. Login Protocol

3. Registration Protocol

4. Get My Page Protocol

5. Getting Furniture Information Protocol

6. Getting Furniture Colors Protocol

7. Classifying Furniture Colors Protocol

8. Furniture Information Compare Protocol

9. Furniture Information Add/Edit Protocol

10. Register Room Image Protocol

11. Extracting Color Protocol

12. Get Representative Color Protocol

13. Comparing Colors Protocol

14. Marking No Match Color Protocol

15. Selecting Protocol

16. Furniture Information Protocol

17. Recommending Protocol

18. Receiving Feedback Protocol

19. Feedback Saving Protocol

20. DCGAN Image Generating Protocol

21. Optimal Furniture Arrangement Protocol

9. Database Design

    14. Objective

    15. ER Diagram

        23. Entity

        24. Relationship

    16. Relational Schema

        25. User

        26. Furniture

        27. Color

        28. Selection

    17. Normalization

    18. SQL DDL

        29. User

        30. Furniture

        31. Color

        32. Selection

10. Testing Plan

    19. Objective

    20. Testing Policy

    21. Test Case

        33. User Management System

        34. Furniture Information System

        35. Color Analyzing System

4. Personalizing System

5. Image Processor System

11. Development Environment

    22. Objective

    23. Programming Language & IDE

1. Programming Language

2. IDE

    24. Coding Rule

    25. Version Management Tool

12. Develop Plan

 A. Objective

 B. Gantt Chart

 C. Domain

13. Index

    26. Table Index

    27. Figure Index

    28. Diagram Index

14. Reference

1. **P****reface**

    1. **Objective**

 Preface에서는 해당 문서의 구조와 규칙에 대해 설명하고, 본 문서의 예상 독자와 문서들의 버전 업데이트 기록에 대해 서술한다. 이를 통해, 해당 문서의 이해를 돕는다.

    2. **Readership**

 해당 문서의 독자는 Colorful Square 시스템을 개발하는 소프트웨어 엔지니어와 시스템을 설계하고 개발에 참여하는 모든 구성원으로 정의한다. 해당 시스템을 개발할 때 외부 업체에 외주를 맡기게 된다면, 해당 업체에서 개발에 관여하는 모든 사람 역시 문서의 독자에 포함한다. 즉, 본 시스템의 개발 및 유지보수와 관련된 모든 구성원을 해당 문서의 독자로 정의한다.

    3. **Document Structure**

 해당 문서는 Preface, Introduction, System Architecture, User Management System, Furniture Information System, Color Analyzing System, Personalizing System, Image Processor System, Protocol Design, Database Design, Testing Plan, Development Environment, Develop Plan, Index 14개의 섹션으로 나뉘어져 있다. 아래의 내용은 각 섹션에 대한 개요를 보여준다. 

        1. **Preface**

  Preface에서는 해당 문서의 구조와 규칙에 대해 설명하고, 본 문서의 예상 독자와 문서들의 버전 업데이트 기록에 대해 서술한다. 이를 통해, 해당 문서의 이해를 돕는다.

        2. **Introduction**

 Introduction에서는 Colorful Square 시스템을 설계할 때 문서에서 언급되는 모든 종류의 다이어그램 및 설계 시 사용하는 툴에 대해 설명한다. 

        3. **System Architecture**

 System Architecture에서는 개발하고자 하는 Colorful Square 시스템의 전반적인 구조에 대해 Layered Architecture Diagram을 통해 설명한다. 해당 시스템의 전체 구조를 Block Diagram으로 나타내었고, Package Diagram과 Deployment Diagram을 이용해 각 시스템의 관계와 실제 사용 방식을 설명한다. 각 시스템에 대한 상세 기술은 IV~VIII장에 걸쳐 기술한다.

        1. **User Management System**

 User의 이용 측면과 관련된 시스템으로, User의 회원 가입과 로그인을 관리하는 시스템의 설계를 설명한다. User가 이미지 및 가구 등을 저장하고 확인할 수 있는 MyPage 시스템의 설계에 대해서도 설명한다. Class Diagram, Sequence Diagram, State Diagram을 통해 User Management System의 구조를 나타낸다.

        2. **Furniture Information System**

 Furniture Information system은 여러 가구 사의 웹사이트에서 가구의 정보를 수집, 편집하여 저장한다. 가구 정보를 크롤링 해오고, 크롤링 해온 데이터를 시스템에서 사용할 수 있도록 처리한다. Class Diagram, Sequence Diagram, State Diagram을 통해 Furniture Information System의 구조를 나타낸다.

        3. **Color Analyzing System**

 Color Analyzing System은 이미지의 색상을 분석하여 Dominant Colors를 추출하는 Extracting Color System과 No Match Color를 추출하기 위한 color comparison system으로 구성된다. User 방 이미지에 No Match Color의 영역을 표시하기 위해 Image Processor System의 일부가 포함된다.  Class Diagram, Sequence Diagram, State Diagram을 통해 Color Analyzing System의 구조를 나타낸다.

        4. **Personalizing System**

 시스템 내에서 가구 추천 및 추천에 대한 학습이 이루어지는 시스템의 설계를 설명한다. Personalizing System은 하위 2개의 시스템을 가지고 있다. Furniture Recommendation System은 User의 기본 정보 및 방 이미지를 바탕으로 가구를 추천해주는 시스템이다. Learning Recommendation System은 추천해 준 가구에 대한 User의 피드백을 바탕으로 학습이 이루어지는 시스템이다. Class Diagram, Sequence Diagram, State Diagram을 통해 Personalizing System의 구조를 표현한다.

        5. **Image Processor System**

 Image Processor System은 Colorful Square 상의 이미지 자료에 대한 일련의 처리를 담당하는 시스템이다. Furniture Arrangement System은 User가 선택한 가구를 3D Modeling하여 User의 방에 배치해주는 시스템이다. Image Generating System은 User가 업로드한 방 이미지가 이상향으로 변하는 과정의 이미지 생성 및 최적 배치한 결과에 대한 이미지를 생성하는 시스템이다. Class Diagram, Sequence Diagram, State Diagram을 통해 Image Processor System의 구조를 표현하고 설명한다.

        6. **Protocol Design**

 Protocol Design에서는 Sub-system 간의 상호작용에 대한 Protocol에 대해 서술한다.  Protocol의 기본 형식은 JSON이며, 통신하는 메시지의 형식, 용도, 의미를 설명한다.

        7. **Database Design**

 Database Design에서는 요구사항을 바탕으로 ER Diagram, Relational schema를 작성하고, Normalization을 거쳐 Redundancy와 Anomaly를 제거한 후 SQL DDL을 작성한다.

        8. **Testing Plan**

Testing Plan은 시스템이 개발자가 설계 및 의도한대로 실행되는지 확인하고 시스템 내부의 결함을 찾기 위한 Testing을 계획한다. Testing Plan에서는 Testing Policy와 여러 Test Case에 대해 서술한다.

        9. **Development Environment**

 Development Environment에서는 개발자가 시스템을 개발하는 환경에 대해 서술한다. 개발 시 사용하는 프로그래밍 언어와 IDE에 대해 서술한다. 각종 코딩 규칙과 버전 관리를 위한 방안에 대해서도 기술한다.

        10. **Develop Plan**

 Develop Plan에서는 개발 계획과 실제 개발 흐름에 대해 서술한다.  Gantt Chart를 이용하여 현재까지의 진행 상황과 앞으로의 개발 계획을 나타낸다.

        11. **Index**

 Index에서는 문서에 참조된 표, Diagram, 그림의 순서를 나타낸다.

    4. **Document Version**

        4. **Version Format**

	 버전 번호는 단일 숫자로 표현한다. 문서의 버전은 0부터 시작한다.

        5. **Version Management**

 이전 버전의 내용을 수정하거나 새로운 내용을 추가할 때마다 버전을 업데이트한다. 다만 하나의 회의를 진행하는 도중에 이루어진 변경은 버전 번호를 업데이트하지 않고, 해당 회의가 끝났을 때의 최종 변경을 업데이트 사항으로 간주한다.

        6. **Version Update History**

<table>
  <tr>
    <td>Version</td>
    <td>Modified date</td>
    <td>Explanation</td>
  </tr>
  <tr>
    <td>0</td>
    <td>2018.05.09</td>
    <td>System과 Sub-system 식별.</td>
  </tr>
  <tr>
    <td>1</td>
    <td>2018.05.10</td>
    <td>전체 시스템의 Block Diagram, Layered Architecture 기술. User Management System의 System Architecture 기술.</td>
  </tr>
  <tr>
    <td>2</td>
    <td>2018.05.11</td>
    <td>Furniture Information System, Personalizing System, Color Analyzing System,Learning recommendation system,Color comparison system,Image generating system, Image Processor System의 System architecture 기술.</td>
  </tr>
  <tr>
    <td>3</td>
    <td>2018.05.12</td>
    <td>User Management System, Furniture Information System, Color Analyzing System의 Class Diagram 기술.</td>
  </tr>
  <tr>
    <td>4</td>
    <td>2018.05.13</td>
    <td>Personalizing System Class Diagram, Image Processor System 기술.</td>
  </tr>
  <tr>
    <td>5</td>
    <td>2018.05.14</td>
    <td>User Management System, Furniture Information System, Personalizing System의 Sequence Diagram 및 State Diagram 기술.</td>
  </tr>
  <tr>
    <td>6</td>
    <td>2018.05.16</td>
    <td>Image Processor System, Color Analyzing System의 Sequence Diagram 및 State Diagram 기술.</td>
  </tr>
  <tr>
    <td>7</td>
    <td>2018.05.17</td>
    <td>Database Design,Relation Schema,ER Diagram 기술.</td>
  </tr>
  <tr>
    <td>8</td>
    <td>2018.05.18</td>
    <td>Personalizing System, Color Analyzing System, Furniture Information System의 protocol description 기술. Testing plan 기술.</td>
  </tr>
  <tr>
    <td>9</td>
    <td>2018.05.19</td>
    <td>User Management System, Image Processor System의 protocol description 기술, 문서 보완.</td>
  </tr>
</table>


**Table 1 Version Update**

1. **I****ntroduction**

1. ** Objective**

 Introduction에서는 Colorful Square 시스템을 설계할 때 문서에서 언급되는 모든 종류의 다이어그램 및 설계 시 사용하는 툴에 대해 설명한다. 

2. ** Applied Diagram**

1. **UML**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_0.png)

**Figure 1 Unified Modeling Language(UML) logo**

 Unified Modeling Language(UML)은 소프트웨어 공학에서 사용되고 있는 표준으로써, 객체 관리 그룹(OMG)에 의해 관리되고 개선되고 있는 범용 모델링 언어이다. UML 그 자체는 개발 방법이 아니지만, 객체 지향 소프트웨어 개발 방법론에 부합하도록 설계되었다. UML의 여러 그래픽 요소는 다이어그램을 그리는데 사용된다. UML은 여러 그래픽 요소들을 조합하고 표기하는 규칙들도 포함한다. 

 개발자는 UML을 통해 객체 지향적인 설계에 따라 나올 수 있는 산출물에 대해서도 표기할 수 있다. 시스템의 모델을 다양한 관점에서 표기할 수 있기 때문에, 오류가 발생할 수 있는 상황을 예측해볼 수 있는 도구로 쓰이기도  한다. 시스템의 구조도와 흐름도를 작성하여 개발 구성원들이 하나의 시스템에 대해 합의할 수 있고, 계약사항을 만들 때에도 합의할 수 있는 기준이 될 수 있다.

 UML은 만들어진 이래 지속적으로 발전하고 있다. 다양한 소프트웨어 회사들이 UML을 사용하면서, 다양한 회사들의 피드백을 수렴하고 피드백 하기 위해 UML 컨소시엄이 발족되었다. 버전이 올라가면서 UML이 표현할 수 있는 범위와 방식이 정교해졌다. 

 UML의 표현 방법은 크게 모델과 뷰로 나눌 수 있다. UML이 시스템을 표현하기 위해 다양한 다이어그램과 그래픽 요소들을 사용해야 한다. 이러한 그래픽 요소들이 어떻게 합쳐져야 하는지에 대한 규칙을 정의하는 것을 모델이라고 한다. UML 모델은 시스템 자체가 어떻게 행동해야 하는지에 대해 설명하는 언어이나 시스템의 구현 방법을 설명하는 수단은 아니다. 이러한 단점은 xUML이라는 실행가능한 추상화된 소프트웨어 언어가 생기게 된 계기이기도 하다.

 UML의 장점은 크게 4가지로 분류될 수 있다. 

 첫 번째는 가시화 언어라는 점이다. 가시화 언어는 시스템의 개념 모델을 작성할 수 있는 언어이다. 오류 없이 해당 객체를 표현할 수 있으며, 의사소통이 용이한 그래픽 언어이다. 

 두 번째는 명세화 언어라는 점이다. 명세화 언어란, 시스템이 어떻게 구성되어야 하는지에 대한 정확한 모델을 제시할 수 있고, 완전한 형태의 모델을 작성할 수 있는 언어이다. 시스템을 분석하고 시스템을 설계할 수 있는 용도로 사용할 수 있다.

 세 번째는 구축 언어라는 점이다. UML은 다양한 프로그램과 다양한 프로그래밍 언어에 적용시킬 수 있는 추상화된 언어이다. 추상화를 통해 UML에서 프로그래밍 언어로 구현할 수 있고, 반대로 프로그래밍 언어로 구현된 프로그램에 대해 UML로 추상화 시킬 수도 있다. UML의 왕복성은 실행 시스템을 예측할 수 있게 해주는 중요한 특성이다.

 네 번째는 문서화 언어라는 점이다. UML은 시스템에 대해 평가하고, 시스템의 구성요소와 외부요소를 구분지을 수 있도록 경계를 명확히 할 수 있는 언어이다. 개발자 뿐만 아니라 소프트웨어 개발자와 클라이언트가 합의할 수 있는 구체적인 사실 적시에 적합하다.

 UML에서 시스템을 표현할 때 쓰는 다이어그램에는 Class Diagram, Component Diagram, Deployment Diagram, State Diagram,Sequence Diagram이 있다. 

2. **Package Diagram**

** **Package Diagram이란 모델을 구성하는 Package 들 간의 dependency를  Unified Model Language로 작성한 것을 의미한다. 각각의 패키지 요소들은 그룹으로 조직하기에 용이하고 탭이 달린 폴더로 표현된다. 이러한 표기법을 통해 대규모의 시스템 속에서 중요한 요소들을 파악하고, 각각의 요소들의 관계를 파악할 수 있다. Package Diagram에는 하위 package, 상위 package 등의 요소들이 있을 수 있다. 또한 패키지 안에는 Use Case, Activity Diagram등도 담길 수 있다. 패키지는 시스템의 boundary를 지키고, 해당 패키지를 사용해야 하는 개발자들이 쉽게 이해하고 사용할 수 있어야 한다.

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_1.png)

**Figure 2 Package Diagram Example**

3. **Deployment Diagram**

** **Deployment Diagram은 하드웨어와 소프트웨어를 노드로 보고, 이들의 물리적인 관계를 명시하는 UML의 모델이다. 시스템을 구성하는 하드웨어 간의 연결 관계를 표현하고 데이터의 표현 방식과 이동 경로에 대해서도 표기한다. 노드는 접속과 처리가 가능한 하나의 요소이다. 노드는 소프트웨어의 컴포넌트가 될 수도, 하드웨어가 될 수도 있다. Deployment Diagram은 설계하고자 하는 시스템의 물리적 아키텍쳐를 담당하며, 이를 통해 시스템에 필요한 하드웨어를 식별하고, 하드웨어에 필요한 소프트웨어도 정의할 수 있다. 마지막으로 Deployment Diagram을 통해 요구사항 명세서의 Non-Functional Requirement를 확인할 수 있다.

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_2.png)

**				****Figure 3 Deployment Diagram Example**

4. **Class Diagram**

 Class diagram은 시스템의 구조를 Class 단위로 식별하여 정적인 다이어그램으로 표현하는 모델이다. Class diagram을 통해 시스템의 개념적인 모델링을 할 수 있고, 이를 통해 프로그래밍 언어 코드로 변환 할 수 있다. 

 Class diagram은 세 가지 요소로 구성되어 있다. 제일 상위 요소는 Class의 이름을 정의하는 곳으로 다른 프로그래밍 언어 작성 규칙과 같이, 반드시 첫 글자는 대문자, 단수형으로 작성한다. 중간 요소는 attribute를 작성하는 곳으로 attribute의 이름과, 자료형에 대해 작성한다. 마지막 요소는 operation으로 불리기도 하는데, Class가 실행할 수 있는 함수들을 의미한다.

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_3.png)

**Figure 4 Class Diagram Example**

5. **Sequence Diagram**

 Sequence Diagram은 시스템이 동작하는 다양한 측면을 기술할 수 있는 대표적인 다이어그램이다. 하나의 시스템 속에서 어떠한 event가 시작되었을 때, 생성되고 소멸되는 객체를 표기하고, 객체들 사이에 주고 받는 메시지를 명시한다. 횡축을 시간축으로 하고, 위에서부터 아래로 하나의 method 에 대해 작성함으로써, 횡적으로나 종적으로나 시간의 변화에 따라 시스템에서 어떠한 event가 발생하는지에 대해서 파악할 수 있다. 그렇기 때문에 Event diagram이나 Event Scenario라고 불리기도 한다. Sequence Diagram은 하나의 action과 event가 파편화 되어 일어난다는 가정 하에 diagram을 작성한다.

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_4.png) 

**Figure 5 Sequence Diagram Example**

6. **State Diagram**

 State Diagram이란 시스템의 기능과 상태를 나타내기 위한 다이어그램이다. State diagram에서는 하나의 객체에 대한 상태 변화를 나타낸다. 한 객체는 이벤트와 메시지에 따라 다양한 상태로 변할 수 있다. 시스템 안의 모든 객체에 대한 diagram은 불필요하다. 따라서 State diagram을 작성할 때는 반드시 특정 조건을 만족하는 객체에 대해서만 작성하며, 그 조건을 만족하는 기간에 대해서도 반드시 명시해주어야 한다. 또한, State diagram은 유한한 상태를 가지는 하드웨어, 소프트웨어를 명시하는 것에도 쓰일 수 있다. State diagram은 최소 시작하는 상태와 변화하는 상태 2가지를 가진다.

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_5.png)

**Figure 6 State Diagram Example**

7. **ER Diagram**

**	 **ER Diagram은 현실세계에 존재하는 데이터들을 추상화하고, 추상화된 객체를 사람이 이해할 수 있도록 표시하는 방법 중 하나이다. 개념적 모델링을 하는 대표적인 도구로, 사각형과 원 그리고 마름모를 이용해 작성된다. ER Diagram은 entity들의 관계 뿐만 아니라 해당 entity의 attribute, 그리고 이들의 cardinality에 대해 표현한다. 이러한 작성법 덕분에, ER Diagram은 데이터베이스를 설계하고 추상화 할 수 있는 중요한 도구이다. ER Diagram은 두 객체가 서로 relation이 되어 있다고 가정한다. 따라서, 서로 relation이 없는 정보는 ER Diagram으 표현하기 어렵다.

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_6.png)

**Figure 7 ER Diagram Example**

3. ** Applied Tool**

        1. **Gliffy & EdrawMax**

**	** 본 문서에 첨부되어 있는 모든 시스템 설계도와 diagram의 작성은 'Gliffy'와 ‘EdrawMax’ tool을 사용한 것이다. 우선, Gliffy는 HTML 5 클라우드 기반 애플리케이션을 통해 다이어그램을 그리는 소프트웨어이다. UML 다이어그램, 평면도, 벤 다이어그램, flow chart 등 다양한 종류의 다이어그램을 온라인으로 작성하는데 사용된다. 사용자와 실시간으로 공유하고 편집할 수 있다는 장점을 갖고 있다.

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_7.png)

**Figure 8 Gliffy Screenshot**

** **

 EdrawMax는 flow chart, 조직도, 네트워크 다이어그램, 비즈니스 프레젠테이션, 마인드 맵 뿐만 아니라 다양한 삽화 등을 쉽게 만들 수 있는 교차 플랫폼 다이어그램 소프트웨어이다.

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_8.png)

**Figure 9 EdrawMax Screenshot**

        2. **Project Studio**

** **본 문서에 첨부되어 있는 Gantt Chart는 'Project Studio'를 사용하여 얻은 것이다. ‘Project Studio’는 Microsoft Store를 통해 다운로드 받을 수 있으며, 가입하지 않아도 기본적인 서비스 이용이 가능하다. 진행하는 project와 그 안의 task들을 임의로 입력할 수 있으며, 각각의 task에 진행 시작 날짜와 완료 날짜를 입력하여 전체 task를 진행 날짜별로 한 눈에 확인할 수 있다. 둘 이상의 project에 해당하는 task들을 한 화면에서 확인할 수 있어 편리하다. 

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_9.png)

**Figure 10 Project Studio Screenshot**

        3. **Amazon Web Services(AWS)**

 Amazon Web Service(AWS)는 Amazon에서 제공하는 클라우드 서비스 플랫폼이다. 컴퓨팅 파워, 스토리지 옵션, 네트워킹 및 데이터베이스같은 다양한 인프라 서비스를 제공한다.  컴퓨팅 파워를 조절할 수 있어, 원하는 컴퓨터 환경에서 서비스를 테스트해 볼 수 있다. 

	![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_10.png)

**Figure 11 Amazon Web Services logo**

**  **

4. ** Project Scope**

 Colorful Square(컬러풀 스퀘어) System은 가구 추천 시스템으로, 크게 두 가지 기능을 제공한다. 

 우선, User의 방 이미지의 색상을 분석하여 방에 부합하는 가구를 추천해 준다. User는 추천받은 가구 중에서 마음에 드는 가구를 선택할 수 있다. 해당 시스템은 추가로 User가 선택한 가구가 방에 배치되어 있는 사진을 보여주는 기능을 제공한다. 또한, User의 방 이미지가 이상향으로 변화하는 과정을 보여주어, 방 인테리어에 대한 Guideline을 제시한다.

 Colorful Square System은 시스템은 User Management System, Furniture Information System, Color Analyzing System, Personalizing System Image Processor System 5개의 시스템으로 이루어져있다.

 ![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_11.png)

**Figure 12 Management System의 구조**

 User Management System은 User의 이용과 관련된 시스템으로 Log in Sub system, Sign Up Sub System, Mypage Sub System으로 이루어져 있다. Login Sub System은 로그인 기능을 제공하고, Sign Up Sub System은 회원 가입 기능을 제공한다. Mypage Sub System은 해당 서비스를 이용하며 User가 선택했던 정보를 확인, 수정 및 삭제하는 기능을 제공한다. 

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_12.png)

**Figure 13 Furniture Information System의 구조**

 Furniture Information System은 가구 정보를 관리하는 시스템으로 Set Up Furniture Sub system과 Update Furniture Data Sub System으로 구성된다. Set Up Furniture Sub System은 DB에 가구 정보를 저장하는 시스템으로 가구사에서 가구 정보를 가져와 저장한다. Update Furniture Data Sub System은 DB를 최신으로 업데이트 하는 시스템으로, 가구 DB에 정보를 추가,수정,삭제한다. 

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_13.png)

**Figure 14 Color Analyzing System의 구조**

 Color Analyzing System은 이미지에서 색을 추출하고, 색을 비교하는 시스템으로 Extracting Color Sub System과 Color Comparison Sub System으로 구성된다. Extracting Color Sub System은 색상 분석을 통해 이미지에서 대표색을 찾아내는 기능을 제공한다. Color Comparison Sub System은 두 개의 이미지를 비교하여, 어떤 색이 다른지 알아내고, 하나의 이미지에 No Match Color를 표시하는 기능을 제공한다.

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_14.png)

**Figure 15 Personalizing System의 구조**

 Personalizing System은 가구를 추천하고 학습하는 시스템으로 Furniture Recommendation Sub System과 Learning Recommendation Sub System으로 구성된다. Furniture Recommendation Sub System은 가구를 추천하는 기능을 제공한다. Learning Recommendation Sub System은 User의 피드백을 바탕으로 학습하는 시스템이다.

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_15.png)

	**Figure 16 Image Processor System의 구조**

 Image Processor System은 Image Generating Sub System과 Furniture Arrangement Sub System으로 구성된다. Image Generating Sub System은 user의 방 이미지가 이상향으로 변화하는 과정을 보여주는 기능을 제공한다. Furniture Arrangement Sub System은 user의 방 이미지에 가구를 배치하여 합성된 이미지를 보여주는 기능을 제공한다.

**	**

2. **S****ystem Architecture**

1. ** Objective**

 System Architecture에서는 개발하고자 하는 Colorful Square 시스템의 전반적인 구조에 대해 Layered Architecture Diagram을 통해 설명한다. 해당 시스템의 전체 구조를 Block Diagram으로 나타내었고, Package Diagram과 Deployment Diagram을 이용해 각 시스템의 관계와 실제 사용 방식을 설명한다. 각 시스템에 대한 상세 기술은 IV~VIII장에 걸쳐 기술한다.

2. ** System Organization**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_16.png)

**Diagram**** 1 Layered Architecture**

 Colorful Square 시스템은 Layered Architecture를 사용하여 구현된다. 각 layer는 다른 layer에 어떠한 데이터를 요청하거나 받을 수 있다. 각 layer는 독립적으로 구성되어, 각자의 역할을 수행하면 전체의 시스템은 문제 없이 돌아간다. 시스템이 배포 된 이후에 evolution 을 거치며 각각의 layer가 수정 및 보완이 되는 과정에도 다른 layer에 독립적으로 성능을 개선시킬 수 있다.  각 부분들은 하나의 이슈만을 담당하기 때문에 각 layer들 사이의 결합성은 낮으나, 응집성을 높여 시스템 전체적으로 안정성이 높아진다. 해당 시스템의 전체 아키텍처는 layered architecture 이지만, 구체적인 설계 단계에서는 layer마다 여러 아키텍처와 디자인 패턴을 사용하여, 각 패턴들의 장점들을 취할 수 있다.

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_17.png)

**Diagram 2 Block Diagram**

1. **User Management System**

 User Management System의 경우, user의 이용과 관련된 시스템으로, user의 회원가입을 관리하는 Signup Sub-system과 로그인 기능을 제공하는 Login Sub-system 그리고 user의 마이페이지 기능을 제공하는 Mypage Sub-system, 총 3개의 하위 시스템으로 나뉜다.

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_18.png)

**Diagram 3 Sign up/ Log in System Architecture**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_19.png)**Diagram 4 My Page System Architecture**

2. **Furniture Information System**

 Furniture Information system은 여러 가구 사의 웹사이트에서 가구의 정보를 수집, 편집하여 저장한다. 가구 정보를 크롤링 해오고, 크롤링 해온 데이터를 시스템에서 사용할 수 있도록 처리한다. Furniture Information System은 Set Up Furniture Data Sub System과 Update Furniture Data Sub System으로 나뉜다.

**Diagram 5 Furniture Information System Architecture**

3. **Color Analyzing System**

 Color Analyzing System은 이미지의 색을 분석하고 비교하는 시스템으로,  Extracting color system과 Comparing Color System으로 이루어져 있다. Extracting color system은 이미지에서 색을 분석하여 dominant colors를 알아내는 시스템이다. Comparing Color system은 Extracting color system을 통해 나온 색을 토대로 이미지를 비교하는 시스템이다. 

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_20.png)

**Diagram 6 Extracting Color System Architecture**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_21.png)

**Diagram 7 Color Comparison System Architecture**

4. **Personalizing System**

 Personalizing system은 Furniture Recommendation System과 Learning Recommendation System으로 구성된다 전자는 user 정보와 user의 방 이미지 정보를 바탕으로 가구를 추천해주는 시스템이다. 후자는 추천해 준 가구에 대한 user의 피드백을 바탕으로 학습하는 시스템이다. 

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_22.png)**Diagram 8 Furniture Recommendation System Architecture**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_23.png)

**Diagram 9 Learning Recommendation System Architecture**

5. **Image Processor System**

 Image Processor System은 Colorful Square 상의 이미지 자료에 대한 일련의 처리를 담당하는 시스템으로 두 개의 하위 시스템이 있다. Furniture Arrangement Sub System은 User가 업로드한 방 이미지와 선택한 가구를 3D Modeling하여 User의 방에 배치해주는 시스템이다. Image Generating Sub-System은 User가 업로드한 방 이미지가 이상향으로 변하는 과정의 이미지 생성 및 최적 배치한 결과에 대한 이미지를 생성하는 시스템이다.

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_24.png)

**Diagram 10 Furniture Arrangement System Architecture**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_25.png)

**		****Diagram 11 Image Generating System Architecture**

    1. **Package Diagram**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_26.png)

**Diagram 12 Package Diagram**

    2. **Deployment Diagram**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_27.png)

**Diagram 13 Deployment Diagram 1**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_28.png)

**Diagram 14 Deployment Diagram 2**

3. **U****ser Management System**

1. ** Objectives**

 User의 이용 측면과 관련된 시스템으로, User의 회원 가입과 로그인을 관리하는 시스템의 설계를 설명한다. User가 이미지 및 가구 등을 저장하고 확인할 수 있는 MyPage 시스템의 설계에 대해서도 설명한다. Class diagram, sequence diagram, state diagram을 통해 user management system의 구조를 표현하고 설명한다.

2. ** Class Diagram**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_29.png)

**Diagram 15 User Management System Class Diagram**

1. **DB Handler**

**1-1. Attributes**

**		**해당 사항 없음.

	**1-2. Methods**

**		**read(): Database의 데이터를 읽어온다.

		write(): Database에 데이터를 입력한다.

		delete(): Database에 데이터를 삭제한다.

		compare(): Database에 있는 데이터와 입력하려는 데이터를 비교한다.

2. **User**

**2-1. Attributes**

**		**-id: User ID

		-password: User password

		-gender: User gender

		-phoneNum: User phone number

		-age: User age

		-email: User email address

		-name: User name

	**2-2. Methods**

		Private 변수들에 대한 각각의  get과 set method는 기본으로 한다.

3. **Sequence Diagram**

1. **Sign up using Facebook**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_30.png)

**Diagram 16 User Management System Sequence Diagram 1**

2. **Sign in using Facebook**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_31.png)

**Diagram 17 User Management System Sequence Diagram 2**

3. **Sign up without using Facebook**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_32.png)

**Diagram 18 User Management System Sequence Diagram 3**

4. **Sign in without using Facebook**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_33.png)

**Diagram 19 User Management System Sequence Diagram 4**

4. ** State Diagram**

1. **Sign up**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_34.png)

**Diagram 20 User Management System State Diagram 1**

2. **Sign in**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_35.png)

**Diagram 21 User Management System State Diagram 2**

4. **F****urniture Information System**

1. ** Objectives**

 Furniture Information system은 여러 가구 사의 웹사이트에서 가구의 정보를 수집, 편집하여 저장한다. 가구 정보를 크롤링 해오고, 크롤링 해온 데이터를 시스템에서 사용할 수 있도록 처리한다. Dominant colors를 가져올 때 Color Analyzing System의 일부가 포함된다.

2. ** Class Diagram**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_36.png)

**Diagram 22 Furniture Information System Class Diagram**

1. **DB Handler**

**	1-1. Attributes**

**		**해당 사항 없음.

	**1-2. Methods**

**		**read(): Database의 데이터를 읽어온다.

		write(): Database에 데이터를 입력한다.

		delete(): Database에 데이터를 삭제한다.

		compare(): Database에 있는 데이터와 입력하려는 데이터를 비교한다.

2. **Furniture**

**	2-1. Attributes**

**		**+web_Link: 가구의 웹사이트 링크

		+brand: 가구의 브랜드

		+colors: 가구의 dominant colors

		+name: 가구의 이름

		+type:  가구의 타입

		+specificType: 가구의 구체적인 타입

		+material: 가구의 재료

		+rank: 가구의 평점 (5점 만점)

	**2-2. Methods**

**		**해당 사항 없음.

3. **Color**

**	3-1. Attributes**

**		**+rgb: 이미지의 rgb값

		+repColor: 원래 rgb값이 해당되는 범위를 가진 대표 rgb값

	**3-2. Methods**

**		**getRepColor(): 대표 rgb값을 추출한다.

4. **Gather Information**

**	4-1. Attributes**

**		**+web_Link: 웹사이트 주소

	**4-2. Methods**

**		**access(): 웹사이트에 접근한다.

		download(): 데이터를 다운로드 한다.

5. **Gather Furniture Information**

**	5-1. Attributes**

**		**해당 사항 없음.

	**5-2. Methods**

extractData(): 다운로드된 데이터를 Furniture class에 넣을 수 있도록 해준다.

6. **Gather Color Information**

**	6-1. Attributes**

**		**+imageLink(): 이미지의 주소

	**6-2. Methods**

**		**getRgb(): 이미지의 dominant rgb값을 가져온다.

3. **Sequence Diagram**

1. **Setup Furniture Data System**

**	** ![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_37.png)

**Diagram 23 Furniture Information System Sequence Diagram 1**

2. **Update Furniture Data System**

	 ![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_38.png)

**Diagram 24 Furniture Information System Sequence Diagram 2**

4. **State Diagram**

1. **Setup Furniture Data System**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_39.png)

**Diagram 25 Furniture Information System State Diagram 1**

2. **Update Furniture Data System**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_40.png)

**Diagram 26 Furniture Information System State Diagram 2**

5. **C****olor Analyzing System**

1. **Objectives**

 이미지에서 색상을 분석하는 시스템의 설계를 설명한다. Color analyzing system에는 Dominant Colors를 추출하는 Extracting color system과 no match color를 추출하기 위한 color comparison system이 포함된다. User 방 이미지에 no match color의 영역을 표시하기 위해 image processor system의 일부가 포함된다.

2. **Class Diagram**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_41.png)

**Diagram 27 Color Analyzing System Class Diagram**

1. **DB Handler**

**	1-1. Attributes**

**		**해당 사항 없음.

	**1-2. Methods**

**		**read(): Database의 데이터를 읽어온다.

		write(): Database에 데이터를 입력한다.

		delete(): Database에 데이터를 삭제한다.

		compare(): Database에 있는 데이터와 입력하려는 데이터를 비교한다.

2. **Furniture**

**	2-1. Attributes**

**		**+web_Link: 가구의 웹사이트 링크

		+brand: 가구의 브랜드

		+colors: 가구의 dominant colors

		+name: 가구의 이름

		+type:  가구의 타입

		+specificType: 가구의 구체적인 타입

		+material: 가구의 재료

		+rank: 가구의 평점 (5점 만점) 

	**2-2. Methods**

**		**해당 사항 없음.

3. **Color**

**	3-1. Attributes**

**		**+rgb: 이미지의 rgb값

		+repColor: 원래 rgb값이 해당되는 범위를 가진 대표 rgb값

	**3-2. Methods**

**		**getRepColor(): 대표 rgb값을 추출한다.

4. **Gather Information**

**	4-1. Attributes**

**		**+web_Link: 웹사이트 주소

	**4-2. Methods**

**		**access(): 웹사이트에 접근한다.

		download(): 데이터를 다운로드 한다.

5. **Gather Furniture Information**

**	5-1. Attributes**

**		**해당 사항 없음.

	**5-2. Methods**

extractData(): 다운로드된 데이터를 Furniture class에 넣을 수 있도록 해준다.

6. **Gather Color Information**

**	6-1. Attributes**

**		**+imageLink(): 이미지의 주소

	**6-2. Methods**

**		**getRgb(): 이미지의 dominant rgb값을 가져온다.

7. **Compare**

**	7-1. Attributes**

**		**+colorA: User 방 image의 dominant colors

		+colorB: DCGAN image의 dominant colors

	**7-2. Methods**

**		**getNoMatchColor(): Nomatch color를 추출한다.

8. **Image Producing**

**	8-1. Attributes**

**		**+imageA: User 방 이미지

		+imageB: 이상향 이미지

		+noMatchColor: Nomatch color

	**8-2. Methods**

**		**getDCGAN(): DCGAN이미지를 생성한다.

markNoMatchColor(): User 방 이미지에 nomatch color 영역을 표시한다.

3. **Sequence Diagram**

    1. **Color Analyzing System**

**	**![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_42.png)**Diagram 28 Color Analyzing System Sequence Diagram 1**

    2. **Color Comparison System	**![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_43.png)

**Diagram 29 Color Analyzing System Sequence Diagram 2**

4. **State Diagram**

    3. **Color Analyzing System**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_44.png)

**Diagram 30 Color Analyzing System State Diagram 1**

    4. **Color Comparison System**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_45.png)

**Diagram 31 Color Analyzing System State Diagram 2**

6. **P****ersonalizing System**

1. **Objectives**

 시스템 내에서 가구 추천 및 추천에 대한 학습이 이루어지는 시스템의 설계를 설명한다. Personalizing System은 하위 2개의 시스템을 가지고 있다. Furniture Recommendation System은 User의 기본 정보 및 방 이미지를 바탕으로 가구를 추천해주는 시스템이다. Learning Recommendation System은 추천해 준 가구에 대한 User의 피드백을 바탕으로 학습이 이루어지는 시스템이다.  

2. **Class diagram**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_46.png)

**Diagram 32 Personalizing System Class Diagram**

1. **DB Handler**

**	1-1. Attributes**

**		**해당 사항 없음.

**	1-2. Methods**

**	** 	+read(): Database의 데이터를 읽어온다.

		+write(): Database에 데이터를 입력한다.

		+delete(): Database에 데이터를 삭제한다.

		+compare(): Database에 있는 데이터와 입력하려는 데이터를 비교한다.

**      2. Classifier**

**	** **2-1. Attributes**

**		**+dnnClassifier: 추천 모델이다.

**2-2. Methods**

**		**feed(string[]): User의 feedback을 바탕으로 학습을 한다.

predict(string[]): String : User에게 부합하는 가구를 추천해준다.

3. **Sequence Diagram**

    1. **Furniture Recommendation System**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_47.png)**Diagram 33 Personalizing System Sequence Diagram 1**

    2. **Learning Recommendation System**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_48.png)

**Diagram 34 Personalizing System Sequence Diagram 2**

4. **State Diagram **

    3. **Furniture Recommendation System**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_49.png)

**Diagram 35 Personalizing System State Diagram 1**

    4. **Learning Recommendation System**

**	** ![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_50.png)

**Diagram 36 Personalizing System State Diagram 2**

7. **I****mage Processor System**

1. **Objectives**

 Image Processor System은 Colorful Square 상의 이미지 자료에 대한 일련의 처리를 담당하는 시스템이다. Furniture Arrangement System은 User가 선택한 가구를 3D Modeling하여 User의 방에 배치해주는 시스템이다. Image Generating System은 User가 업로드한 방 이미지가 이상향으로 변하는 과정의 이미지 생성 및 최적 배치한 결과에 대한 이미지를 생성하는 시스템이다.

2. **Class diagram**

**Diagram 37 Image Processor System Class Diagram**

1. **DB Handler**

**	1-1. Attributes**

**		**해당 사항 없음.

**	1-2. Methods**

**	** 	+read(): Database의 데이터를 읽어온다.

		+write(): Database에 데이터를 입력한다.

		+delete(): Database에 데이터를 삭제한다.

		+compare(): Database에 있는 데이터와 입력하려는 데이터를 비교한다.

**     2. Furniture**

**2-1. Attributes**

**		**+web_Link: 가구의 웹사이트 링크

		+brand: 가구의 브랜드

		+colors: 가구의 dominant colors

		+name: 가구의 이름

		+type:  가구의 타입

		+specificType: 가구의 구체적인 타입

		+material: 가구의 재료

		+rank: 가구의 평점 (5점 만점)

**2-2. Methods**

**		**해당 사항 없음.

**      3. Image Handler**

**3-1. Attributes**

**		**해당 사항 없음.

**3-2. Methods**

 DCGAN_Generator(string[]): string[] : DCGAN을 통해 User의 방 이미지가 이상향으로 변해가는 과정을 보여주는 이미지 4장을 생성한다.

**     4. 3D Model Handler**

**4-1. Attributes**

**		**해당 사항 없음.

**4-2. Methods**

+convert2Dto3D(string): string : User가 선택한 가구의 2D 이미지를 3D 모델링한다.

+convert3Dto2D(string): string : 3D 모델링한 결과를 다시 2D 이미지로 바꾸어서 User에게 보여준다.

+furnitureArrangement(string): string : User가 선택한 가구를 3D 모델링한 결과물을 User의 방 이미지에 배치해준다.

**     5. Gather Information**

**5-1. Attributes**

**		**+web_Link: 웹사이트 주소

**5-2. Methods**

**		**access(): 웹사이트에 접근한다.

		download(): 데이터를 다운로드 한다.

**      6. Gather Color Information**

**	** **6-1. Attributes**

**		**+imageLink(): 이미지의 주소

**6-2. Methods**

getRgb(): 이미지의 dominant rgb값을 가져온다.

3. **Sequence Diagram**

1. **Image Generating System**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_51.png)

**Diagram 38 Image Processor Sequence Diagram 1**

2. **Furniture Arrangement System**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_52.png)

**Diagram 39 Image Processor System Sequence Diagram 2**

4. **State Diagram **

1. **Image Generating System**

**	** ![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_53.png)

**Diagram 40 Image Processor System State Diagram 1**

**    2. Furniture Arrangement System**

**	**![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_54.png)

**Diagram 41 Image Processor System State Diagram 2**

8. **P****rotocol Design**

1. **Objective**

 Protocol Design에서는 subsystems간의 상호작용에 대한 protocol에 대해 서술한다.  Protocol의 기본 형식은 JSON이며, 통신하는 메시지의 형식, 용도, 의미를 설명한다.

2. **JSON**

**	**![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_55.png)

**Figure 17 JSON logo**

 JSON(JavaScript Object Notation)은 속성-값 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷이다. 비동기 브라우저/서버 통신을 위해, 넓게는 XML을 대체하는 주요 데이터 포맷이다. 특히, 인터넷에서 자료를 주고 받을 때 그 자료를 표현하는 방법으로 알려져 있다. 자료의 종류에는 큰 제한은 없으며, 특히 컴퓨터 프로그램의 변수 값을 표현하는 데 적합하다.

3. **Protocol Description**

1. **Overview**

 HTTP 통신에서 client와 server 사이에서 전송되는 메시지의 형태를 용도별로 정의한다. Client에서의 요청(request) 메시지와 server에서의 응답(response) 메시지로 구분한다. 

2. **Login Protocol**

**2-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>id</td>
    <td>user의 id</td>
  </tr>
  <tr>
    <td>password</td>
    <td>user의 비밀번호</td>
  </tr>
</table>


**Table**** 2 Login Protocol 1**

**2-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>login_success</td>
    <td>로그인 성공 여부</td>
  </tr>
</table>


**Table 3 Login Protocol 2**

3. **Registration Protocol**

**3-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>id</td>
    <td>user의 id</td>
  </tr>
  <tr>
    <td>password</td>
    <td>user의 비밀번호</td>
  </tr>
  <tr>
    <td>name</td>
    <td>user의 이름</td>
  </tr>
  <tr>
    <td>phone</td>
    <td>user의 핸드폰 번호</td>
  </tr>
  <tr>
    <td>email</td>
    <td>user의 이메일 주소</td>
  </tr>
  <tr>
    <td>gender</td>
    <td>user의 성별</td>
  </tr>
  <tr>
    <td>age</td>
    <td>user의 나이</td>
  </tr>
</table>


**Table 4 Registration Protocol 1**

**3-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>reg_success</td>
    <td>회원가입 성공 여부</td>
  </tr>
</table>


**Table 5 Registration Protocol 2**

4. **Get My Page Protocol**

**	4-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>user_id</td>
    <td>user의 아이디</td>
  </tr>
</table>


**Table 6 Get My Page Protocol 1**

**4-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>selection
img_link</td>
    <td>유저가 선택한 이미지의 주소값</td>
  </tr>
</table>


**Table 7 Get My Page Protocol 2**

5. **Getting Furniture Information Protocol**

	**5-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>web_link</td>
    <td>가구사 홈페이지 주소</td>
  </tr>
</table>


**Table 8 Getting Furniture Information Protocol 1**

**	****5-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>furniture_name</td>
    <td>가구 이름</td>
  </tr>
  <tr>
    <td>brand</td>
    <td>가구 브랜드</td>
  </tr>
  <tr>
    <td>type</td>
    <td>가구 종류</td>
  </tr>
  <tr>
    <td>rank</td>
    <td>가구 평점</td>
  </tr>
  <tr>
    <td>material</td>
    <td>가구 재질</td>
  </tr>
  <tr>
    <td>specific_type</td>
    <td>가구 세부 종류</td>
  </tr>
  <tr>
    <td>image_link</td>
    <td>가구 이미지 주소</td>
  </tr>
</table>


**Table 9 Getting Furniture Information Protocol 2**

6. **Getting Furniture Colors Protocol**

**	6-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>image_link</td>
    <td>가구 이미지 주소</td>
  </tr>
</table>


**Table 10 Getting Furniture Colors Protocol 1**

**	6-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>rgb</td>
    <td>가구 이미지의 rgb 값</td>
  </tr>
</table>


**Table 11 Getting Furniture Colors Protocol 2**

7. **Classifying Furniture Colors Protocol**

**7-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>rgb</td>
    <td>가구 이미지의 rgb 값</td>
  </tr>
</table>


**Table 12 Classifying Furniture Colors Protocol 2**

**7-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>rep_color</td>
    <td>rgb 값이 속한 색범위의 대표색</td>
  </tr>
</table>


**Table 13 Getting Furniture Colors Protocol 2**

8. **Furniture Information Compare Protocol**

**8-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>furniture_name</td>
    <td>가구 이름</td>
  </tr>
  <tr>
    <td>brand</td>
    <td>가구 브랜드</td>
  </tr>
  <tr>
    <td>colors</td>
    <td>가구 rep_color들의 집합</td>
  </tr>
  <tr>
    <td>type</td>
    <td>가구 종류</td>
  </tr>
  <tr>
    <td>rank</td>
    <td>가구 평점</td>
  </tr>
  <tr>
    <td>material</td>
    <td>가구 재질</td>
  </tr>
  <tr>
    <td>specific_type</td>
    <td>가구 세부 종류</td>
  </tr>
</table>


**Table 14 Furniture Information Compare Protocol 1**

**8-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>compare_done</td>
    <td>가구 정보 중복 여부 확인</td>
  </tr>
</table>


**Table 15 Furniture Information Compare Protocol 2**

9. **Furniture Information Add/Edit Protocol**

**9-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>furniture_name</td>
    <td>가구 이름</td>
  </tr>
  <tr>
    <td>brand</td>
    <td>가구 브랜드</td>
  </tr>
  <tr>
    <td>colors</td>
    <td>가구 rep_color들의 집합</td>
  </tr>
  <tr>
    <td>type</td>
    <td>가구 종류</td>
  </tr>
  <tr>
    <td>rank</td>
    <td>가구 평점</td>
  </tr>
  <tr>
    <td>material</td>
    <td>가구 재질</td>
  </tr>
  <tr>
    <td>specific_type</td>
    <td>가구 세부 종류</td>
  </tr>
</table>


**Table 16 Furniture Information Add/Edit Protocol 2**

**9-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>write_success</td>
    <td>가구 정보 추가/수정 성공</td>
  </tr>
</table>


**Table 17 Furniture Information Add/Edit Protocol 2**

10. **Register Room Image Protocol**

**10-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>roomImg_url</td>
    <td>User 방 이미지의 URL</td>
  </tr>
  <tr>
    <td>idealImg_url</td>
    <td>이상향 방 이미지의 URL</td>
  </tr>
</table>


**Table 18 Register Room Image Protocol 1**

**10-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>reg_success</td>
    <td>이미지 업로드 성공 여부</td>
  </tr>
</table>


**Table 19 Register Room Image Protocol 2**

11. **Extracting Color Protocol**

**11-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>img_url</td>
    <td>이미지의 URL</td>
  </tr>
</table>


**Table 20 Extracting Color Protocol 1**

**11-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>colors_list</td>
    <td>이미지에서 추출한 색상의 모든 RGB 값 목록</td>
  </tr>
  <tr>
    <td>extr_success</td>
    <td>업로드한 이미지에서 색상 추출 성공</td>
  </tr>
</table>


**Table 21 Extracting Color Protocol 2**

12. **Get Representative Color Protocol**

**12-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>colors_list</td>
    <td>이미지에서 추출한 색상의 모든 RGB 값 목록</td>
  </tr>
</table>


**Table 22 Get Representative Color Protocol 1**

**12-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>rep_colors</td>
    <td>RGB 값을 계열에 따라 분류하고, 이미지에서 차지하는 비율이 큰 상위 5개 대표 색상들의 목록 </td>
  </tr>
</table>


**Table 23 Get Representative Color Protocol 1**

13. **Comparing Colors Protocol**

**13-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>colorlist_1</td>
    <td>User 방 이미지의 대표색 리스트</td>
  </tr>
  <tr>
    <td>colorlist_2</td>
    <td>이상향 이미지의 대표색 리스트</td>
  </tr>
</table>


**Table 24 Comparing Colors Protocol 1**

**13-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>noMatchColor</td>
    <td>두 대표색 리스트를 비교하여 일치하지 않는 색상 결과 목록</td>
  </tr>
</table>


**Table 25 Comparing Colors Protocol 1**

14. **Marking No Match Color Protocol**

**14-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>roomImg_url</td>
    <td>User 방 이미지의 URL</td>
  </tr>
  <tr>
    <td>noMatchColor</td>
    <td>User의 방 이미지와 이상향 이미지 사이에 일치하지 않는 색상</td>
  </tr>
</table>


**Table 26 Marking No Match Color Protocol 1**

**14-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>mark_success</td>
    <td>No Match Color 표시 이미지 display 성공 여부</td>
  </tr>
</table>


**Table 27 Marking No Match Color Protocol 2**

15. **Selecting Protocol**

**	15-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>furniture_type</td>
    <td>가구 종류</td>
  </tr>
  <tr>
    <td>color</td>
    <td>색 띠 중에 선택된 하나의 색</td>
  </tr>
</table>


**Table 28 Selecting Protocol 1**

**15-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>sel_success</td>
    <td>선택 성공</td>
  </tr>
</table>


**Table 29 Selecting Protocol 2**

16. **Furniture Information Protocol**

**	16-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>color</td>
    <td>user가 선택한 가구 색상</td>
  </tr>
  <tr>
    <td>type</td>
    <td>user가 선택한 가구 종류</td>
  </tr>
</table>


**Table 30 Furniture Information Protocol 1**

**16-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>furniture_name</td>
    <td>가구 이름</td>
  </tr>
  <tr>
    <td>brand</td>
    <td>가구 브랜드</td>
  </tr>
  <tr>
    <td>type</td>
    <td>가구 종류</td>
  </tr>
  <tr>
    <td>rank</td>
    <td>가구 평점</td>
  </tr>
  <tr>
    <td>material</td>
    <td>가구 재질</td>
  </tr>
  <tr>
    <td>specific_type</td>
    <td>가구 세부 종류</td>
  </tr>
  <tr>
    <td>image_link</td>
    <td>가구 이미지 주소</td>
  </tr>
</table>


**Table 31 Furniture Information Protocol 2**

17. **Recommending Protocol**

**	17-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>furniture_
infomations</td>
    <td>가구 정보들의 목록</td>
  </tr>
</table>


**Table 32 Recommending Protocol 1**

**17-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>recom_furniture</td>
    <td>최종적으로 추천하는 가구</td>
  </tr>
</table>


**Table 33 Recommending Protocol 2**

18. **Receiving Feedback Protocol**

**	18-1. Request	**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>feedback</td>
    <td>추천 가구 Accept 여부</td>
  </tr>
</table>


**Table 34 Receiving Feedback Protocol 1**

**	18-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>feedback_
success</td>
    <td>feedback 수신 여부</td>
  </tr>
</table>


**Table 35 Receiving Feedback Protocol 2**

19. **Feedback Saving Protocol**

**	19-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>feedback</td>
    <td>추천에 대한 Accept 여부</td>
  </tr>
</table>


**Table 36 Feedback Saving Protocol 1**

**	19-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>save_success</td>
    <td>DB에 피드백 저장 성공 여부</td>
  </tr>
</table>


**Table 37 Feedback Saving Protocol 2**

20. **DCGAN Image Generating Protocol**

**	20-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>user_room</td>
    <td>user의 방 이미지</td>
  </tr>
  <tr>
    <td>ideal</td>
    <td>이상향</td>
  </tr>
</table>


**Table 38 Image Generating Protocol 1**

**20-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>gen_image</td>
    <td>user_room과 ideal이 조합되어 생성된 DCGAN 이미지들</td>
  </tr>
</table>


**Table 39 Image Generating Protocol 2**

21. **Optimal Furniture Arrangement Protocol**

**	21-1. Request**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>user_room</td>
    <td>user의 방 이미지</td>
  </tr>
  <tr>
    <td>frni_selected</td>
    <td>user가 user_room에 넣고 싶은 가구</td>
  </tr>
</table>


**Table 40 Optimal Furniture Arrangement Protocol 1**

**21-2. Response**

<table>
  <tr>
    <td>Attribute</td>
    <td>Value</td>
  </tr>
  <tr>
    <td>frni_arrimg</td>
    <td>user_room에 가구가 배치된 사진 </td>
  </tr>
</table>


**Table 41 Optimal Furniture Arrangement Protocol 2**

9. **D****atabase Design**

1. **Objective**

 Database Design에서는 요구사항 명세서에서 기술한 데이터베이스 요구사항을 바탕으로, 설계명세서를 작성하는 과정에서 수정된 요구사항들을 포함하였다. 

 우선, 수정 내용을 반영하여 ER diagram, Relation Schema를 작성 하였다. 또한, Normalization에서는 해당 시스템의 DB의 종류와 개수가 많지 않음을 고려하였다. 따라서, 제 1 정규화만 진행하였으며, 이를 통해 Redundnacy와 Anomaly를 제거 하였다. 마지막으로 위의 정규화를 바탕으로 SQL DDL 문을 작성하였다. 

2. **ER Diagram**

 사각형은 Entity를 표현한다. Entity는, attribute를 가질 수 있다. attribute는 타원형으로 표현하며, Entity 에 연결된다. 모든 Entity는 고유하게 식별되는 attribute 집합을 가지고 있다.

 Entity들의 관계는 다이아몬드로형으로 표현되며, 실선과 점선으로 연결된다.

실선은 양쪽 entity의 키가 모두 기본키인 경우를 표현하며, 점선은 한쪽 entity만 기본키일 경우를 표현한다.

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_56.png)

**Diagram 42 Overall ER Diagram**

1. **Entity**

**1-1. User**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_57.png)

**Diagram 43 User Entity**

 **User**는 회원 정보를 나타낸다.** ****_id_****_, name, password, email, phone number, gender, age_**의 속성을 갖고 있다. Primary key는** id**이다.

**			**

**1-2. Furniture**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_58.png)

**Diagram 44 Furniture Entity**

**Furniture**는 가구 정보를 나타낸다. **_furniture_name, brand, colors, type, rank, material, specific type, webs_link_**의 속성을 갖고 있다. 기본 키는**_ web_link_**이다.

**1-3. Color**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_59.png)

**Diagram 45 Color Entity**

**Color**는 색에 대한 정보를 표현한다. **_rep_color, max, min_** 속성을 갖는다. Primary Key는 **_rep_color_**이다.

**1-4. Selection**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_60.png)

**Diagram 46 Selection Entity**

 **Selection**은 **User**가 선택한 가구에 대한 정보를 나타낸다. **_id_****_, web_Link_***, ***_arrangeImg_url_**을 가지고 있다. Primary key는 **arrangeImg_url**이며, **id, web_link**는 Foreign Key로 설정한다.

2. **Relationship**

**2-1. Select Furniture Relationship**

**Diagram 47 Select Furniture Relationship**

** **Select Furniture Relationship은 User가 추천받은 가구를 선택하여 마이페이지에 관리하는 관계로, 한 명의 User가 여러 개의 가구를 선택할 수 있다.

**2-2. Get Furniture Data Relationship**

**	 **Get Furniture Relationship은 크롤링한 가구 데이터를 Furniture DB에

넣고, user가 선택한 가구를 selection DB에 넣는 관계를 나타낸 것이다. selection DB에서 하나의 선택은 반드시 하나의 가구 정보를 가지고 있어야 하고, 하나 이상 가질 수 없다. 가구 정보는 selection DB에 의해 n개 선택될 수 있고, 하나도 선택되지 않을 수 있다. 

**Diagram 48 Get Furniture Data Relationship**

**2-3. Confirm Color Relationship**

**Diagram 49 Confirm Color Relationship**

** **Confirm Color Relationship은 크롤링 해온 가구의 색상을 모든 색상 범주가 저장되어 있는 color DB에 보내서 가구의 대표 색상을 확인하는 관계이다. Color DB는 furniture data와 일치하는 부분도, 입력되는 부분도 없다. 하지만 Furniture DB는 가구의 색상 정보에 따라 최소 하나에서 최대 세 개의 대표색을 가질 수 있다.

3. ** Relational Schema**

1. **User**

<table>
  <tr>
    <td>ID</td>
    <td>password</td>
    <td>name</td>
    <td>gender</td>
    <td>age</td>
  </tr>
  <tr>
    <td>phone_number</td>
    <td></td>
    <td>email</td>
    <td></td>
    <td></td>
  </tr>
</table>


Primary Key (PK): ID

	Foreign Key (FK): 없음.

	FUNCT DEP (FD):

		ID → { password, name, gender, age, phone_number, email}

		name → {ID, password, gender, age, phone_number, email}

Description: Entity User에 관한 테이블이다. 모든 속성에 NULL을 허용하지 않는다.

2. **Furniture**

<table>
  <tr>
    <td>web_link</td>
    <td>furniture_name</td>
    <td></td>
    <td>brand</td>
    <td>colors</td>
  </tr>
  <tr>
    <td>type</td>
    <td>specific_type</td>
    <td></td>
    <td>rank</td>
    <td>material</td>
  </tr>
</table>


Primary Key (PK): web_link

	Foreign Key (FK): 없음.

	FUNCT DEP (FD):

web_link → {furniture_name, brand, colors, type, specific_type, rank, material}

Description: Entity Furniture에 관한 테이블이다. Rank에만 NULL을 허용하고, 나머지 속성에 대해서는 NULL을 허용하지 않는다.

3. **Color	**

<table>
  <tr>
    <td>rep_color</td>
    <td>min</td>
    <td>max</td>
  </tr>
</table>


Primary Key (PK): rep_color

	Foreign Key (FK): 해당 없음

	FUNCT DEP (FD):

		rep_color → {min, max}

Description: Entity Color에 관한 테이블이다. 모든 속성에 NULL을 허용하지 않는다.

4. **Selection	**

<table>
  <tr>
    <td>arrangeImg_url</td>
    <td></td>
    <td></td>
  </tr>
</table>


Primary Key (PK): arrangeImg_url

	Foreign Key (FK): ID, web_link

	FUNCT DEP (FD):

		arrangeImg_url → {ID, web_link}

Description: Entity Selection에 관한 테이블이다. ID는 User DB의 Foreign Key이고, web_link는 Furniture DB의 Foreign Key이다. 모든 속성에 NULL을 허용하지 않는다.

4. ** Normalization**

관계형 데이터베이스 설계에서 중요한 것은 중복을 최소화 하는 것이다. 데이터베이스에서의 중복은 속도를 느리게 하고, 데이터를 만들고, 수정하고, 지우고 읽는 과정에서 오류를 발생시킬 수 있다. 크고 제대로 조직되지 않은 entity 들의 coupling을 최소화 함과 동시에, 작게 잘 조직되어 있으며, 서로의 관계가 명확한 entity로 설계하는 것이 database design의 목적이다. BCNF 정규화를 통해  하나의 테이블에서 삽입, 삭제, 변경되는 사항들이 있다면, 해당 테이블을 참조하고 있는 다른 테이블에서도 해당 사항들이 자동으로 변경되게 할 수 있다.

 해당 시스템의 데이터베이스는 entity가 많지 않기에 높은 수준의 정규화를 하더라도, 이로 인해 얻을 수 있는 이익이 크지 않다. 따라서 제 3.5 정규화(BCNF 정규형)를 적용하여, 데이터베이스의 구조를 확장해야 할 경우에 데이터베이스를 다시 디자인 해야 하는 상황을 방지하고, 데이터를 사용하는 시스템과 User에게 데이터 모델이 더욱 의미있도록 하였다.

 BCNF를 만족하는지 확인하기 위해 모든 DB의 결정자가 후보키가 될 수 있는지 확인하였다. 그 결과 User DB에서 유저가 선택한 가구의 column 내용이 BCNF를 충족하지 않았다. 따라서 유저가 선택한 가구에 대한 entity를 selection DB로 새로이 작성하였고, 선택한 가구에 관한 column을 user DB에서 삭제하였다. 이를 통해  insert anomaly, update anomaly, delete anomaly와 같은 이상 현상을 해결하였고, 해결된 DB 설계를 바탕으로 SQL DDL 문을 작성하였다. 

5. **SQL DDL**

**    1. User**

<table>
  <tr>
    <td>CREATE TABLE 'User' (
    ‘ID’ varchar(30) NOT NULL,
    ‘password’ varchar(45) NOT NULL,
    ‘name’ varchar(45) NOT NULL,
    ‘gender’ int(1) NOT NULL,
    ‘phone_number’ int(11) NOT NULL,
    ‘age’ int(3) NOT NULL,
    ‘email’ varchar(100) NOT NULL,
    PRIMARY KEY (‘ID’)
    UNIQUE KEY ‘ID_UNIQUE’ (‘ID’)
) ENGINE=InnoDB DEFAULT CHARSET=utf8</td>
  </tr>
  <tr>
    <td>ID는 PRIMARY KEY이므로 NOT NULL이다. </td>
  </tr>
</table>


**    2. Furniture**

<table>
  <tr>
    <td>CREATE TABLE 'Furniture' (
    ‘web_link’ varchar(100) NOT NULL,
    ‘furniture_name’ varchar(45) NOT NULL,
    ‘brand’ varchar(45) NOT NULL,
    ‘colors’ varchar(45) NOT NULL,
    ‘type’ varchar(45) NOT NULL,
    ‘rank’ float(3) DEFAULT NULL,
    ‘material’ varchar(45) NOT NULL,
    ‘specific_type’ varchar(45) NOT NULL,
    PRIMARY KEY (‘web_link’)
    UNIQUE KEY ‘web_link_UNIQUE’ (‘web_link’)
) ENGINE=InnoDB DEFAULT CHARSET=utf8</td>
  </tr>
  <tr>
    <td>web_link는 PRIMARY KEY이므로 NOT NULL이다. </td>
  </tr>
</table>


**    3. Color**

<table>
  <tr>
    <td>CREATE TABLE 'Color' (
    ‘rep_color’ varchar(45) NOT NULL,
    ‘min’ varchar(45) NOT NULL,
    ‘max’ varchar(45) NOT NULL,
    PRIMARY KEY (‘rep_color’)
    UNIQUE KEY ‘rep_color_UNIQUE’ (‘rep_color’)
) ENGINE=InnoDB DEFAULT CHARSET=utf8</td>
  </tr>
  <tr>
    <td>rep_color는 PRIMARY KEY이므로 NOT NULL이다. </td>
  </tr>
</table>


**    4. Selection**

<table>
  <tr>
    <td>CREATE TABLE 'Selection' (
    ‘ID’ varchar(30) NOT NULL,
    ‘web_link’ varchar(100) NOT NULL,
    ‘arrangeImg_url’ varchar(100) NOT NULL,
    PRIMARY KEY (‘arrangeImg_url’)
    UNIQUE KEY ‘arrangeImg_url_UNIQUE’ (‘arrangeImg_url’)
    KEY ‘user_ID’ (‘ID’),
    KEY ‘furniture_web_link’ (‘web_link’),
    CONSTRAINT ‘user’ FOREIGN KEY (‘ID’) REFERENCES ‘User’ (‘ID’) ON DELETE NO ACTION ON UPDATE CASCADE,
    CONSTRAINT ‘furniture’ FOREIGN KEY (‘web_link’) REFERENCES ‘furniture’ (‘web_link’) ON DELETE NO ACTION ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8</td>
  </tr>
  <tr>
    <td>arrangeImg_url은 PRIMARY KEY이므로 NOT NULL이다. </td>
  </tr>
</table>


10. **T****esting Plan**

1. ** Objective**

 Testing Plan은 시스템이 개발자가 설계 및 의도한대로 실행되는지 확인과 시스템 내부의 결함을 찾기 위해 testing하는 것을 계획한다. Testing Plan에서는 testing policy와 test case들에 대해 얘기한다.

2. **Testing Policy**

 ColorfulSquare 시스템 개발에서는 4단계의 test가 이루어 진다. 

<table>
  <tr>
    <td>Level</td>
    <td>Owner</td>
    <td>Objective(s)</td>
    <td>Key Areas of Testing</td>
  </tr>
  <tr>
    <td>component</td>
    <td>Development</td>
    <td>component에서 defective code 찾기
component가 failure할 확률 줄이기</td>
    <td>Functionality</td>
  </tr>
  <tr>
    <td>Integration</td>
    <td>Development</td>
    <td>class interfaces에서 defects 찾기
dataflow와 workflow가 failure할 확률 줄이기</td>
    <td>Functionality, data quality, performance, compatibility, class interoperability</td>
  </tr>
  <tr>
    <td>System</td>
    <td>Quality Assurance</td>
    <td>use cases에서 defects 찾기
요구 사항 명세서와 다른 부분 찾기</td>
    <td>Functionality, data quality, performance, reliability, usability,
portability, interoperability</td>
  </tr>
  <tr>
    <td>Acceptance</td>
    <td>Business</td>
    <td>user workflow에서 defects 찾기
user가 가지고 있는 정보로 test</td>
    <td>Functionality</td>
  </tr>
</table>


**Table 42 Testing Policy**

3. **Test Case**

1. **User Management System**

**1-1. Log in for User using 'Facebook'**

1. User: 'Facebook'을 이용하여 로그인을 시도한다.

2. 시스템 동작: User DB에 저장되어 있는 데이터와 접속을 시도하는 User의 정보 일치 여부를 확인한다.

2-1) (로그인 성공) 시스템 동작: 해당 아이디로 로그인한다.

2-2) (로그인 실패) 시스템 동작: Facebook을 통한 회원가입을 자동으로 실행한다. Colorful Square로의 정보 제공 동의를 요청하며, Facebook 가입시 입력한 정보들을 받아온다.

	**1-2. Log in for User without using 'Facebook'**

1. User: ID와 PW를 입력하여, 로그인을 시도한다.

2. 시스템 동작: User DB에 저장되어 있는 데이터와 접속을 시도하는 User의 정보 일치 여부를 확인한다.

2-1) (로그인 성공) 시스템 동작: 해당 아이디로 로그인한다.

2-2) (로그인 실패) 시스템 알림: "아이디 또는 패스워드가         일치하지 않습니다."

시스템 동작: 로그인 화면으로 돌아간다.

**1-3. Sign up for User**

1. User: 회원가입을 시도한다.

2. 시스템 동작: 회원가입 양식을 보여준다.

3. User: 회원가입 양식을 작성한 후 제출한다.

4. 시스템 동작: DB에 있는 자료와 중복되는 값이 있는지 확인한다.

4-1)(핸드폰 번호 중복) 시스템 알림: "이미 가입한 회원입니다."

					시스템 동작: 2)로 돌아간다.

			4-2)(ID 중복) 시스템 알림:"이미 사용 중인 ID입니다.”

					시스템 동작: 2)로 돌아간다.

			4-3)(중복 없음) 시스템 동작: 5)로 진행한다.

5. 시스템 동작: DB에 저장한다.

**1-4. Mypage**

2. User: Mypage에 접속을 시도한다.

3. 시스템 동작: Mypage 정보를 보여준다.

4. **Furniture Information System**

**2-1. Setup furniture data**

1. System: 가구 정보를 시스템에 요청한다.

2. 시스템 동작: 가구사 사이트에 접속한다.

2-1) (접속 성공) 시스템 동작: 3)으로 진행한다.

2-2) (접속 실패) 시스템 동작: 오류 정보를 system에 넘기고 종료한다.

3. 시스템 동작: 가구사 사이트 상의 가구 정보를 다운로드한다.

3-1) (다운로드 성공) 시스템 동작: 4)으로 진행한다.

3-2) (다운로드 실패) 시스템 동작: 오류 정보를 system에 넘기고 종료한다.

4. 시스템 동작: 다운로드한 데이터를 가공하여 DB에 저장할 수 있는 형태로 바꾼다.

4-1) (프로세싱 성공) 시스템 동작: 5)으로 진행한다.

4-2) (프로세싱  실패) 시스템 동작: 오류 정보를 system에 넘기고 종료한다.

5. 시스템 동작: 가공한 데이터를 DB에 저장한다.

**	2-2. update furniture data**

1. System: Furniture DB의 자료 업데이트를 시스템에 요청한다.

2. 시스템 동작: Furniture DB에 있는 모든 데이터를 DB Handler의 comparing function으로 넘긴다.

3. 시스템 동작: Furniture DB에 있는 web_link에 접속하여 웹사이트에 올라온 데이터들이 DB에 있는 데이터와 같은지 확인한다.

3-1) (확인 성공) 시스템 동작: 웹사이트의 데이터와 DB의 데이터가 같으면 종료한다.

3-2)(확인  실패) 시스템 동작: 웹사이트의 데이터와 DB의 데이터가 다르면 웹사이트의 데이터로 Furniture DB의 해당 record를 수정하고 종료한다.

5. **Color Analyzing System**

**3-1. Extracting colors**

1. User: 방 이미지를 업로드 한다.

2. 시스템 동작: Google Vision API에 색상 분석을 요청한다.

2-1) (요청 실패) 시스템 동작: 시스템 알림: "색상 분석에 시간이 소요됩니다. 잠시 기다려주세요."

        시스템 동작: Google Vision API에 재요청한다.

3. 시스템 동작: Google Vision API에서 분석한 색상 정보를 color DB에 저장된 색상 범위와 비교한다.

4. 시스템 동작: color DB에 저장된 색상 범위에 따라 대표색을 반환한다.

5. 시스템 동작: User에게 분석된 색 띠를 보여준다.

**3-2. Color comparison**

1. User: User 방 이미지와 이상향 이미지를 등록한다.

1-1) (등록 성공) 시스템 알림: "이미지 등록이 모두 완료되었습니다."

1-2) (등록 실패) 시스템 알림: "죄송합니다. 이미지를 다시 업로드해주세요."

2. 시스템 동작: Google Vision API에 색상 분석을 요청한다.

2-1) (요청 실패) 시스템 동작: 시스템 알림: "색상 분석에 시간이 소요됩니다. 잠시 기다려주세요."

        시스템 동작: Google Vision API에 재요청한다.

3. 시스템 동작: Google Vision API에서 분석한 색상 정보를 color DB에 저장된 색상 범위와 비교한다.

4. 시스템 동작: color DB에 저장된 색상 범위에 따라 대표색을 반환한다.

5. 시스템 동작: 두 이미지의 대표색 리스트 비교를 요청한다.

5-1) (색상 비교 성공) 시스템 동작: No match color 하나를 반환한다.

5-2) (등록 실패) 시스템 알림: "두 이미지의 색상에서 뚜렷한 차이를 찾을 수 없습니다. 이미지를 재업로드 해 주세요."

       시스템 동작: 1)로 돌아간다.

6. 시스템 동작: No match color를 user의 방 이미지에 표시한다.

7. 시스템 동작: User에게 분석된 두 색 띠와 no match color 표시 이미지를 보여준다.

6. **Personalizing System**

**4-1. Furniture Recommendation**

1. User: 가구의 색과 종류를 선택한다.

2. 시스템 동작: 선택 된 가구의 색과 종류에 해당하는 가구 정보를 DB에 요청한다.

2-1) (요청 성공) 시스템 동작: 추천된 가구들을 list 형태로 저장한다. 해당 list  중 가구 1개를 보여준다. 3)으로 진행한다.

2-2) (요청 실패) 시스템 알림: "추천된 가구가 없습니다. 가구의 색과 종류를 다시 입력해주세요."

	시스템 동작: 1)로 돌아간다.

3. User: 추천된 가구를 Accept할 것인지 아닌지 선택한다.

3-1) (Accept): Learning Recommendation, Furniture Arrangement System으로 진행한다.

		3-2) (Deny): 추천된 가구들의 list 내에서 다른 가구를 보여준다. 

	

**4-2. Learning Recommendation**

1. User: 추천받은 가구를 accept할 것인지 말 것인지 선택한다.

2. 시스템 동작: Accept 결과를 DB에 저장한다.

3. 시스템 동작: Accept 결과에 대한 데이터를 바탕으로 학습을 한다.

7. **Image Processor System**

**5-1. Image Generation**

1. User: User 방 이미지와 이상향을 업로드한다.

2. 시스템 동작: Google Vision API에 user의 방 이미지와 이상향에 대한 색상 분석을 요청한다.

2-1) (요청 실패) 시스템 알림: "색상 분석에 시간이 소요됩니다. 잠시 기다려주세요." 

			시스템 동작: Google Vision API에 재요청한다.

3. 시스템 동작: user 방 이미지와 이상향의 대표색 데이터를 보관한다.

4. 시스템 동작: user 방 이미지와 이상향을 dcgan_generator에 입력한다.

5.  시스템 동작: web_link에서 처리 완료된 이미지를 user에게 보여준다.

**5-2. Furniture Arrangement**

1.  User: 추천된 가구를 선택한다.

2. 시스템 동작: OM3D1.0.1에 가구 이미지를 3D 로 변환할 것을 요청한다.

3. 시스템 동작: 방 이미지에 3D로 변환된 가구 이미지를 배치할 것을 System에 요청한다.

4. 시스템 동작: 합성된 이미지를 User에게 보여준다.

11. **D****evelopment Environment**

1. ** Objective**

 Development Environment에서는 개발자가 시스템을 개발하는 환경에 대해 서술한다. 개발 시 사용하는 프로그래밍 언어와 IDE에 대해 서술한다. 각종 코딩 규칙과 버전 관리를 위한 방안에 대해서도 기술한다.

2. ** Programming Language & IDE**

1. **Programming Language**

**	1-1. 서버 개발 언어: Python(Django)**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_61.png)

			**Figure 18 Python logo**

 파이썬은 귀도 판 로썸에 의해 1989년 만들어진 언어로, 초보자들도 배울 수 있을 정도로 단순한 문법과, 다양한 모듈을 가지고 있다.Django는 파이썬으로 만들어진 오픈소스 웹 애플리케이션 프레임워크이다. 프레임워크란 개발자들이 개발을 하면서 쌓아온 경험을 코드로 형상화 시킨 것이다. Django에서는 코드가 제한되는 제어 반전 방식이 사용된다. 이를 통해 쉽고 빠르게 프로그램을 개발 할 수 있다.  

	**1-2. 데이터베이스 관리: SQLite**

** 	**![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_62.png)

**			****Figure 19 SQLite logo**

 SQLite는 클라이언트 응용 어플리케이션에 임베디드되어 동작하는 오픈소스 DBMS의 일종이다. 작은 크기와, 빠른 속도가 장점이다.  작고 단순한 DBMS를 이용하여 전체 시스템이 쓸 수 있는 가용 하드웨어 자원을 확보할 수 있고, 단순한 DB 작업을 하는 시스템의 특성상 SQLite가 Colorful Square 시스템에 적합한 DBMS이다.

2. **IDE**

 GitHub을 통해 버전 관리를 하며, 개발에 참여하는 구성원들의 로컬 개발 환경 상 OS가 같은 관계로, 개발 과정에서 사용한 IDE는 없다. 따라서 이에 대해 따로 기술하지 않는다.

3. ** Coding Rule**

* 버전 관리를 위해 서버에 작업하지 않고 GitHub을 이용하여 코드를 관리한다. 

    * GitHub를 이용하는 경우, 두 명 이상이 동시에 같은 파일을 작업하는 경우가 없도록 한다. 

    * 변수나 함수의 명칭이 명확해야 한다.

    * 주석은 프로그램을 읽는 것과 이해하는 것에 관계된 정보만을 포함하고 있어야 한다.

    * 클래스 체계는 작성하는 사람보다 읽는 사람을 염두에 두고 체계를 잡아야 한다. 

4. ** Version Management Tool**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_63.png)

	**Figure 20 GitHub logo**

 효율적인 개발과 코드의 관리 및 공유를 위해 GitHub를 이용한다. GitHub란, 분산 버전 관리 툴인 깃(Git)을 사용하는 프로젝트를 지원하는 웹호스팅 서비스로, 2015년 기준으로 사용자가 무려 1200만 명이 넘은 신뢰도가 높은 서비스이다. 특히, 깃허브는 오픈소스 소프트웨어의 중심지 역할을 하면서, 오픈소스 프로젝트가 널리 퍼지는데 크게 기여하고 있다.

12. **D****evelop Plan**

1. ** Objective**

 Develop Plan에서는 개발 계획과 실제 개발 흐름에 대해 서술한다.  Gantt Chart를 이용하여 현재까지의 진행 상황과 앞으로의 개발 계획을 나타낸다.

2. ** Gantt Chart**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_64.png)

**Figure 21 Gantt Chart**

 현재까지의 진행 상황과 앞으로의 개발 계획은 위의 Gantt Chart와 같다. 각 문서 작성을 완료하는 시기는 기존의 계획을 크게 벗어나지 않았지만, 초반 아이디어 수립 과정에서 계획과 벗어난 부분이 많았다.

 아이디어 선정 및 제안서 발표 과정에서 예상보다 많은 시간을 소요했다. 제안서 발표 이후에 기존의 아이디어의 한계점을 인식하여 기존의 아이디어를 포기하는 과정이 있었다. 이미 기존의 아이디어로 제안서 발표까지 완료했지만, 더 나은 시스템을 구상하기 위한 결정이었다. 

 7주차에 들어서 새로이 아이디어 구상을 하기 시작했고, 그 결과 나오게 된 것이 현재의 Colorful Square 시스템이다. 아이디어 구상 과정에서 지연이 있었음에도 불구하고, 요구사항 명세서를 9주차까지 계획에 맞게 완성하였다. Design 단계는 요구사항 명세서가 작성된 9주차 이후부터 계획대로 진행하였다. Requirement를 완벽히 파악하기 위해 Design 단계에 들어와서도 끊임없이 이전 문서에 대한 update 작업이 이루어졌다. 해당 문서를 작성 중인 12주차인 현재, 설계명세서도 완성 단계에 근접해 있는 상황이기에, 12주차 안에 설계 명세서 작성 완료를 하겠다는 기존의 계획 달성에도 무리가 없어 보인다.

  Develop 과정은 현 문서 작성 완료 이후인, 13주차 부터 이루어 진다. 구성원들은 각자의 로컬 개발 환경에서 GitHub을 통해 형상관리를 할 것이다. 개발 과정에서 생길 수 있는 오류 상황을  유연하게 대처할 수 있도록 항상 GitHub Branch Integration을 신경써야 한다. 14주차부터는 Sub System들에 대한 Testing이 이루어질 것이며 15주차까지 Integration Testing을 완수할 계획이다. 

 

 문서 작업의 경우, 아이디어를 구상하는 시점부터 작성되기 시작하였다. 따라서, 문서 작성은 3주차부터 15주차까지 시스템 개발 과정 전반에 걸쳐 진행되었다.

3. **Domain**

![image alt text]({{ site.url }}/public/gIWf8sPVgaKNsD0qPumkeA_img_65.png)

**Figure 22 Freenom logo**

 AWS ec2 인스턴스를 사용하여 시스템을 구축하고, 사용자의 웹 접근성을 높이기 위해 도메인을 사용할 것이다. [http://www.freenom.com/](http://www.freenom.com/en/index.html?lang=en) 와 같은 무료 도메인 호스팅 사이트에서 도메인을 배정받아, URL forwarding을 통해 사용자가 해당 시스템의 서버에 들어올 수 있도록 할 것이다.  배정 받을 주소는 아래와 같다. 

colorfulsquare.ml				

13. **I****ndex**

1. **Table Index**

<table>
  <tr>
    <td>Table 번호</td>
    <td>내용</td>
    <td>page</td>
  </tr>
  <tr>
    <td>Table1</td>
    <td>Version update</td>
    <td>10</td>
  </tr>
  <tr>
    <td>Table 2</td>
    <td>Login Protocol 1</td>
    <td>61</td>
  </tr>
  <tr>
    <td>Table 3</td>
    <td>Login Protocol 2</td>
    <td>61</td>
  </tr>
  <tr>
    <td>Table 4</td>
    <td>Registration Protocol 1</td>
    <td>61</td>
  </tr>
  <tr>
    <td>Table 5</td>
    <td>Registration Protocol 2</td>
    <td>61</td>
  </tr>
  <tr>
    <td>Table 6</td>
    <td>Get My Page Protocol 1</td>
    <td>62</td>
  </tr>
  <tr>
    <td>Table 7</td>
    <td>Get My Page Protocol 2</td>
    <td>62</td>
  </tr>
  <tr>
    <td>Table 8</td>
    <td>Getting Furniture Information Protocol 1</td>
    <td>62</td>
  </tr>
  <tr>
    <td>Table 9</td>
    <td>Getting Furniture Information Protocol 2</td>
    <td>62</td>
  </tr>
  <tr>
    <td>Table 10</td>
    <td>Getting Furniture Colors Protocol 1</td>
    <td>63</td>
  </tr>
  <tr>
    <td>Table 11</td>
    <td>Getting Furniture Colors Protocol 2</td>
    <td>63</td>
  </tr>
  <tr>
    <td>Table 12</td>
    <td>Classifying Furniture Colors Protocol 1</td>
    <td>63</td>
  </tr>
  <tr>
    <td>Table 13</td>
    <td>Classifying Furniture Colors Protocol 2</td>
    <td>63</td>
  </tr>
  <tr>
    <td>Table 14</td>
    <td>Furniture Information Compare Protocol 1</td>
    <td>63</td>
  </tr>
  <tr>
    <td>Table 15</td>
    <td>Furniture Information Compare Protocol 2</td>
    <td>64</td>
  </tr>
  <tr>
    <td>Table 16</td>
    <td>Furniture Information Add/Edit Protocol 1</td>
    <td>64</td>
  </tr>
  <tr>
    <td>Table 17</td>
    <td>Furniture Information Add/Edit Protocol 2</td>
    <td>64</td>
  </tr>
  <tr>
    <td>Table 18</td>
    <td>Register Room Image Protocol 1</td>
    <td>65</td>
  </tr>
  <tr>
    <td>Table 19</td>
    <td>Register Room Image Protocol 2</td>
    <td>65</td>
  </tr>
  <tr>
    <td>Table 20</td>
    <td>Extracting Color Protocol 1</td>
    <td>65</td>
  </tr>
  <tr>
    <td>Table 21</td>
    <td>Extracting Color Protocol 2</td>
    <td>65</td>
  </tr>
  <tr>
    <td>Table 22</td>
    <td>Get Representative Color Protocol 1</td>
    <td>65</td>
  </tr>
  <tr>
    <td>Table 23</td>
    <td>Get Representative Color Protocol 2</td>
    <td>66</td>
  </tr>
  <tr>
    <td>Table 24</td>
    <td>Comparing Colors Protocol 1</td>
    <td>66</td>
  </tr>
  <tr>
    <td>Table 25</td>
    <td>Comparing Colors Protocol 2</td>
    <td>66</td>
  </tr>
  <tr>
    <td>Table 26</td>
    <td>Marking No Match Color Protocol 1</td>
    <td>66</td>
  </tr>
  <tr>
    <td>Table 27</td>
    <td>Marking No Match Color Protocol 2</td>
    <td>66</td>
  </tr>
  <tr>
    <td>Table 28</td>
    <td>Selecting Protocol 1</td>
    <td>67</td>
  </tr>
  <tr>
    <td>Table 29</td>
    <td>Selecting Protocol 2</td>
    <td>67</td>
  </tr>
  <tr>
    <td>Table 30</td>
    <td>Furniture Information Protocol 1 </td>
    <td>67</td>
  </tr>
  <tr>
    <td>Table 31</td>
    <td>Furniture Information Protocol 2</td>
    <td>67</td>
  </tr>
  <tr>
    <td>Table 32</td>
    <td>Recommending Protocol 1</td>
    <td>68</td>
  </tr>
  <tr>
    <td>Table 33</td>
    <td>Recommending Protocol 2</td>
    <td>68</td>
  </tr>
  <tr>
    <td>Table 34</td>
    <td>Receiving Feedback Protocol 1</td>
    <td>68</td>
  </tr>
  <tr>
    <td>Table 35</td>
    <td>Receiving Feedback Protocol 2</td>
    <td>68</td>
  </tr>
  <tr>
    <td>Table 36</td>
    <td>Feedback Saving Protocol 1</td>
    <td>69</td>
  </tr>
  <tr>
    <td>Table 37</td>
    <td>Feedback Saving Protocol 2</td>
    <td>69</td>
  </tr>
  <tr>
    <td>Table 38</td>
    <td>DCGAN Image Generating Protocol 1</td>
    <td>69</td>
  </tr>
  <tr>
    <td>Table 39</td>
    <td>DCGAN Image Generating Protocol 2</td>
    <td>69</td>
  </tr>
  <tr>
    <td>Table 40</td>
    <td>Optimal Furniture Arrangement Protocol 1</td>
    <td>69</td>
  </tr>
  <tr>
    <td>Table 41</td>
    <td>Optimal Furniture Arrangement Protocol 2</td>
    <td>70</td>
  </tr>
  <tr>
    <td>Table 42</td>
    <td>Testing Policy</td>
    <td>79</td>
  </tr>
</table>


2. **Figure Index**

<table>
  <tr>
    <td>Figure 번호</td>
    <td>내용</td>
    <td>page</td>
  </tr>
  <tr>
    <td>Figure 1</td>
    <td>Unified Modeling Language(UML) Logo</td>
    <td>12</td>
  </tr>
  <tr>
    <td>Figure 2</td>
    <td>Package Diagram Example</td>
    <td>14</td>
  </tr>
  <tr>
    <td>Figure 3</td>
    <td>Deployment Diagram Example</td>
    <td>15</td>
  </tr>
  <tr>
    <td>Figure 4</td>
    <td>Class Diagram Example</td>
    <td>16</td>
  </tr>
  <tr>
    <td>Figure 5</td>
    <td>Sequence Diagram Example</td>
    <td>17</td>
  </tr>
  <tr>
    <td>Figure 6</td>
    <td>State Diagram Example</td>
    <td>17</td>
  </tr>
  <tr>
    <td>Figure 7</td>
    <td>ER Diagram Example</td>
    <td>18</td>
  </tr>
  <tr>
    <td>Figure 8</td>
    <td>Gliffy Screenshot</td>
    <td>19</td>
  </tr>
  <tr>
    <td>Figure 9</td>
    <td>EdrawMax Screenshot</td>
    <td>19</td>
  </tr>
  <tr>
    <td>Figure 10</td>
    <td>Project Studio Screenshot</td>
    <td>20</td>
  </tr>
  <tr>
    <td>Figure 11</td>
    <td>Amazon Web Services Logo</td>
    <td>21</td>
  </tr>
  <tr>
    <td>Figure 12</td>
    <td>Management System의 구조</td>
    <td>22</td>
  </tr>
  <tr>
    <td>Figure 13</td>
    <td>Furniture Information System의 구조</td>
    <td>22</td>
  </tr>
  <tr>
    <td>Figure 14</td>
    <td>Color Analyzing System의 구조</td>
    <td>23</td>
  </tr>
  <tr>
    <td>Figure 15</td>
    <td>Personalizing System의 구조</td>
    <td>24</td>
  </tr>
  <tr>
    <td>Figure 16</td>
    <td>Image Processor System의 구조</td>
    <td>24</td>
  </tr>
  <tr>
    <td>Figure 17</td>
    <td> JSON logo</td>
    <td>60</td>
  </tr>
  <tr>
    <td>Figure 18</td>
    <td>Python logo</td>
    <td>85</td>
  </tr>
  <tr>
    <td>Figure 19</td>
    <td> SQLite logo</td>
    <td>85</td>
  </tr>
  <tr>
    <td>Figure 20</td>
    <td>GitHub logo</td>
    <td>86</td>
  </tr>
  <tr>
    <td>Figure 21</td>
    <td>Gantt Chart</td>
    <td>87</td>
  </tr>
  <tr>
    <td>Figure 22</td>
    <td>Freenom logo</td>
    <td>88</td>
  </tr>
</table>


3. **Diagram Index**

<table>
  <tr>
    <td>Diagram 번호</td>
    <td>내용</td>
    <td>page</td>
  </tr>
  <tr>
    <td>Diagram 1</td>
    <td>Layered Architecture</td>
    <td>25</td>
  </tr>
  <tr>
    <td>Diagram 2</td>
    <td>Block Diagram</td>
    <td>26</td>
  </tr>
  <tr>
    <td>Diagram 3</td>
    <td>Sign up/ Log in System Architecture</td>
    <td>27</td>
  </tr>
  <tr>
    <td>Diagram 4</td>
    <td>My Page System Architecture</td>
    <td>27</td>
  </tr>
  <tr>
    <td>Diagram 5</td>
    <td>Furniture Information System Architecture</td>
    <td>28</td>
  </tr>
  <tr>
    <td>Diagram 6</td>
    <td>Extracting color System Architecture</td>
    <td>29</td>
  </tr>
  <tr>
    <td>Diagram 7</td>
    <td>Color Comparison System Architecture</td>
    <td>29</td>
  </tr>
  <tr>
    <td>Diagram 8</td>
    <td>Furniture Recommendation System Architecture</td>
    <td>30</td>
  </tr>
  <tr>
    <td>Diagram 9</td>
    <td>Learning Recommendation System Architecture</td>
    <td>31</td>
  </tr>
  <tr>
    <td>Diagram 10</td>
    <td>Furniture Arrangement System Architecture</td>
    <td>32</td>
  </tr>
  <tr>
    <td>Diagram 11</td>
    <td>Image Generating System Architecture</td>
    <td>32</td>
  </tr>
  <tr>
    <td>Diagram 12</td>
    <td>Package Diagram</td>
    <td>33</td>
  </tr>
  <tr>
    <td>Diagram 13</td>
    <td>Deployment Diagram 1</td>
    <td>33</td>
  </tr>
  <tr>
    <td>Diagram 14</td>
    <td>Deployment Diagram 2</td>
    <td>34</td>
  </tr>
  <tr>
    <td>Diagram 15</td>
    <td>User Management System Class Diagram</td>
    <td>35</td>
  </tr>
  <tr>
    <td>Diagram 16</td>
    <td>User Management System Sequence Diagram 1</td>
    <td>36</td>
  </tr>
  <tr>
    <td>Diagram 17</td>
    <td>User Management System Sequence Diagram 2</td>
    <td>37</td>
  </tr>
  <tr>
    <td>Diagram 18</td>
    <td>User Management System Sequence Diagram 3</td>
    <td>37</td>
  </tr>
  <tr>
    <td>Diagram 19</td>
    <td>User Management System Sequence Diagram 4</td>
    <td>38</td>
  </tr>
  <tr>
    <td>Diagram 20</td>
    <td>User Management System State Diagram 1</td>
    <td>38</td>
  </tr>
  <tr>
    <td>Diagram 21</td>
    <td>User Management System State Diagram 2</td>
    <td>39</td>
  </tr>
  <tr>
    <td>Diagram 22</td>
    <td>Furniture Information System Class Diagram</td>
    <td>40</td>
  </tr>
  <tr>
    <td>Diagram 23</td>
    <td>Furniture Information System Sequence Diagram 1</td>
    <td>42</td>
  </tr>
  <tr>
    <td>Diagram 24</td>
    <td>Furniture Information System Sequence Diagram 2</td>
    <td>43</td>
  </tr>
  <tr>
    <td>Diagram 25</td>
    <td>Furniture Information System State Diagram 1</td>
    <td>43</td>
  </tr>
  <tr>
    <td>Diagram 26</td>
    <td>Furniture Information System State Diagram 2</td>
    <td>44</td>
  </tr>
  <tr>
    <td>Diagram 27</td>
    <td>Color Analyzing System Class Diagram</td>
    <td>45</td>
  </tr>
  <tr>
    <td>Diagram 28</td>
    <td>Color Analyzing System Sequence Diagram 1 </td>
    <td>48</td>
  </tr>
  <tr>
    <td>Diagram 29</td>
    <td>Color Analyzing System Sequence Diagram 2</td>
    <td>48</td>
  </tr>
  <tr>
    <td>Diagram 30</td>
    <td>Color Analyzing System State Diagram 1</td>
    <td>49</td>
  </tr>
  <tr>
    <td>Diagram 31</td>
    <td>Color Analyzing System State Diagram 2</td>
    <td>49</td>
  </tr>
  <tr>
    <td>Diagram 32</td>
    <td>Personalizing System Class Diagram</td>
    <td>50</td>
  </tr>
  <tr>
    <td>Diagram 33</td>
    <td>Personalizing System Sequence Diagram 1</td>
    <td>51</td>
  </tr>
  <tr>
    <td>Diagram 34</td>
    <td>Personalizing System Sequence Diagram 2</td>
    <td>52</td>
  </tr>
  <tr>
    <td>Diagram 35</td>
    <td>Personalizing System State Diagram 1</td>
    <td>52</td>
  </tr>
  <tr>
    <td>Diagram 36</td>
    <td>Personalizing System State Diagram 2</td>
    <td>53</td>
  </tr>
  <tr>
    <td>Diagram 37</td>
    <td>Image Processor System Class Diagram</td>
    <td>54</td>
  </tr>
  <tr>
    <td>Diagram 38</td>
    <td>Image Processor System Sequence Diagram 1</td>
    <td>57</td>
  </tr>
  <tr>
    <td>Diagram 39</td>
    <td>Image Processor System Sequence Diagram 2</td>
    <td>58</td>
  </tr>
  <tr>
    <td>Diagram 40</td>
    <td>Image Processor System State Diagram 1</td>
    <td>59</td>
  </tr>
  <tr>
    <td>Diagram 41</td>
    <td>Image Processor System State Diagram 2</td>
    <td>59</td>
  </tr>
  <tr>
    <td>Diagram 42</td>
    <td>Overall ER Diagram</td>
    <td>71</td>
  </tr>
  <tr>
    <td>Diagram 43</td>
    <td>User Entity</td>
    <td>71</td>
  </tr>
  <tr>
    <td>Diagram 44</td>
    <td>Furniture Entity</td>
    <td>72</td>
  </tr>
  <tr>
    <td>Diagram 45</td>
    <td>Color Entity</td>
    <td>72</td>
  </tr>
  <tr>
    <td>Diagram 46</td>
    <td>Selection Entity</td>
    <td>73</td>
  </tr>
  <tr>
    <td>Diagram 47</td>
    <td>Select Furniture Relationship</td>
    <td>73</td>
  </tr>
  <tr>
    <td>Diagram 48</td>
    <td>Get Furniture Data Relationship</td>
    <td>74</td>
  </tr>
  <tr>
    <td>Diagram 49</td>
    <td>Confirm Color Relationship</td>
    <td>74</td>
  </tr>
</table>


14. **R****eference**

[1] Case study in system development - Notes, Lajos Kollár, 2014

<[https://gyires.inf.unideb.hu/GyBITT/07/ch04.html](https://gyires.inf.unideb.hu/GyBITT/07/ch04.html)> (2018.05.17)

[2] 위키피디아 JSON, 2018. 5.11,

 <[https://ko.wikipedia.org/wiki/JSON](https://ko.wikipedia.org/wiki/JSON)> (2018.05.18)

[3] Sample Test Policy, Rex Black, President of RBCS, 2012

<[https://rbcs-us.com/site/assets/files/1386/sample-test-policy.pdf](https://rbcs-us.com/site/assets/files/1386/sample-test-policy.pdf)> (2018.05.19)

[4] 용어로 보는 IT-깃허브, 2015.12.17, <[https://terms.naver.com/entry.nhn?docId=3580149&cid=59088&categoryId=59096](https://terms.naver.com/entry.nhn?docId=3580149&cid=59088&categoryId=59096)>(2018.05.19)

[5] Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks, Alec Radford, Luke Metz, Soumith Chintala, Cornell University Library, 2016.1.7,<[https://arxiv.org/abs/1511.06434](https://arxiv.org/abs/1511.06434)> (2018.05.19)

[6] 위키피디아 Entity-relationship model, 2018.5.15

<[https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model](https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model)> (2018.05.19)

[7] Unified Modeling Language, OMG, 1997, <[http://www.uml.org/](http://www.uml.org/)> (2018.05.19)

[8] EDraw Max, EDrawSoft, 2004, <[https://www.capterra.com/p/82970/EDraw-Max/](https://www.capterra.com/p/82970/EDraw-Max/)> (2018.05.19)

[9] 위키피디아 Gliffy, 2018.4.10, <[https://en.wikipedia.org/wiki/Gliffy](https://en.wikipedia.org/wiki/Gliffy)> (2018.05.19)

[10] Deployment Diagram Examples, Visual Paradigm Community Circle, 2018, <[https://circle.visual-paradigm.com/category/uml-diagrams/deployment-diagram/](https://circle.visual-paradigm.com/category/uml-diagrams/deployment-diagram/)

> (2018.05.19)

[11] Pinterest, <[https://www.pinterest.co.kr/pin/678988081292124904/](https://www.pinterest.co.kr/pin/678988081292124904/)> (2018.05.19)

[12] UML 2 Sequence Diagrams: An Aile Introduction, Scott W. Ambler, 2014, <[http://www.agilemodeling.com/artifacts/sequenceDiagram.htm](http://www.agilemodeling.com/artifacts/sequenceDiagram.htm)> (2018.05.19)

[13] State Machine Diagram Tutorial, Lucidchart, 2018, <[https://www.lucidchart.com/pages/uml-state-machine-diagram](https://www.lucidchart.com/pages/uml-state-machine-diagram)> (2018.05.19)

[14] The Easiest Way to Model ER Diagrams, creately, 2018, <[https://creately.com/ER-diagram-software](https://creately.com/ER-diagram-software)> (2018.05.19)

[15] Gliffy, Gliffy, 2005, <[https://www.gliffy.com/](https://www.gliffy.com/)> (2018.05.19)

[16] Edraw Max, Edraw, 2004, <[https://www.edrawsoft.com/edraw-max.php](https://www.edrawsoft.com/edraw-max.php)> (2018.05.19)

[17] Project Studio, vSoft Studio, 2017, <[https://projectstudio.online/](https://projectstudio.online/)> (2018.05.19)

[18] AWS, Amazon Web Services, Inc., 2018, <[https://aws.amazon.com/](https://aws.amazon.com/)> (2018.05.19)

[19] JSON, Doug Crockford, 2009, <[https://www.json.org/](https://www.json.org/)> (2018.05.19)

[20] Python, Python Software Foundation, 2001, <[https://www.python.org/](https://www.python.org/)> (2018.05.19)

[21] SQLite, Dwayne Richard Hipp, 2000, <[https://www.sqlite.org/index.html](https://www.sqlite.org/index.html)> (2018.05.19)

[22] GitHub, GitHub, 2018, <[https://github.com/](https://github.com/)> (2018.05.19)

[23] Freenom, Freenom, 2018, <[http://www.freenom.com/](http://www.freenom.com/en/index.html?lang=en)> (2018.05.19)

